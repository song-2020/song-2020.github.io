<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://song-2020.Github.io</id>
    <title>脚踏实地，仰望星空</title>
    <updated>2020-07-09T08:46:45.804Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://song-2020.Github.io"/>
    <link rel="self" href="https://song-2020.Github.io/atom.xml"/>
    <subtitle>个人技术博客</subtitle>
    <logo>https://song-2020.Github.io/images/avatar.png</logo>
    <icon>https://song-2020.Github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 脚踏实地，仰望星空</rights>
    <entry>
        <title type="html"><![CDATA[MariaDB]]></title>
        <id>https://song-2020.Github.io/post/mariadb/</id>
        <link href="https://song-2020.Github.io/post/mariadb/">
        </link>
        <updated>2020-07-09T08:21:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<pre><code>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。
</code></pre>
<h1 id="mariadb与mysql">MariaDB与Mysql</h1>
<pre><code>MariaDB虽然被视为MySQL数据库的替代品，但它在扩展功能、存储引擎以及一些新的功能改进方面都强过MySQL。而且从MySQL迁移到MariaDB也是非常简单的：
1、数据和表定义文件（.frm）是二进制兼容的
2、所有客户端API、协议和结构都是完全一致的
3、所有文件名、二进制、路径、端口等都是一致的
4、所有的MySQL连接器，比如PHP、Perl、Python、Java、.NET、MyODBC、Ruby以及MySQL C connector等在MariaDB中都保持不变
5、mysql-client包在MariaDB服务器中也能够正常运行
6、共享的客户端库与MySQL也是二进制兼容的
也就是说，在大多数情况下，你完全可以卸载MySQL然后安装MariaDB，然后就可以像之前一样正常的运行。
</code></pre>
<h1 id="关于xtradb">关于XtraDB</h1>
<pre><code>XtraDB是由Percona开发的一款MySQL数据库的高性能存储引擎，其目的是用来代替InnoDB存储引擎，可用于需要更高性能的环境。XtraDB可以看作是InnoDB存储引擎的增强版本，它在InnoDB上进行了大量的修改和patched，它完全兼容InnoDB，且提供了很多InnoDB不具备的有用的功能。
例如：在多核CPU上面的性能和伸缩性要更好；对于内存的分配和使用也要更好；也解除了InnoDB的很多限制；提供了比InnoDB更多的配置和性能监控参数。
对于高负载的MySQL应用来说，如果不需要MySQL官方技术支持的话，完全可以使用XtraDB来代替InnoDB存储引擎。此外，Percona还提供了打了补丁的MySQL版本，这些补丁对MySQL很多方面进行了改进，性能提高，增加更多监控参数等等。据说JavaEye的数据库就是使用了Percona的版本。
</code></pre>
<h1 id="操作">操作：</h1>
<p><a href="https://blog.csdn.net/weixin_42006882/article/details/104830294?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159428341619195265931480%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=159428341619195265931480&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-9-104830294.first_rank_ecpm_v3_pc_rank_v4&amp;utm_term=mariadb">关于MariaDB的一些操作</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VUE]]></title>
        <id>https://song-2020.Github.io/post/vue/</id>
        <link href="https://song-2020.Github.io/post/vue/">
        </link>
        <updated>2020-07-06T07:50:13.000Z</updated>
        <content type="html"><![CDATA[<p>#为什么要用vue?<br>
传统的网页形式是浏览器脚本语言js连接了各种各样的Html，css，但缺乏正规的组织形式，比如在页面元素非常多，结构很庞大的网页中，数据和视图如果全部混杂在一起，像传统开发一样全部混合在HTML中，那么要对它们进行处理会十分的费劲，并且如果其中有几个结构之间存在藕断丝连的关系，那么会导致代码上出现更大的问题，比如juqery中使用的<br>
<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 3: (&#039;#̲xxx&#039;).parent().…'>(&#039;#xxx&#039;).parent().parent().parent()
一开始很好查找，但当页面结构发生变化，也就是说DOM的关联与嵌套层次要发生改变，那么之前的代码可能就会变成这样了：
</span>('#xxx').parent().parent().parent().parent().parent()<br>
这样产品迭代后，对dom节点的查找操作等行为会有很大的性能损耗。</p>
<p>#vue是一款友好的、多用途的且高性能的js框架，它可以帮你创建可维护性和可测试性更强的代码库。官网对vue的优点描述是这样的：易用、灵活、高效</p>
<p>1.易用：<br>
学习曲线平缓，api简洁，容易上手。学习过程较react来说比较容易，不那么痛苦</p>
<p>2.灵活：<br>
如果你已经有一个现成的服务端框架，你可以将vue作为其中的一部分嵌入，带来更加丰富的交互系统 ，或者你希望将更多业务逻辑放到前端来实现，那么vue的核心库及其生态系统也可以满足你的各式需求，vue允许你将网页分割成可复用的组件，每个组件都可以包含自身的html,css,js文件，以用来渲染网页中相应的地方。</p>
<p>3.高效：<br>
虚拟dom： 其数据全部在内存中，只有js引擎参与其中<br>
而真实dom会有浏览器渲染层在其中</p>
<p>4.社区和第三方组件库丰富</p>
<p>#vue是什么？<br>
<a href="https://blog.csdn.net/weixin_38318244/article/details/85037067?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159399795519725222462702%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=159399795519725222462702&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v4-4-85037067.first_rank_ecpm_v3_pc_rank_v4&amp;utm_term=vue">https://blog.csdn.net/weixin_38318244/article/details/85037067?ops_request_misc=%7B%22request%5Fid%22%3A%22159399795519725222462702%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=159399795519725222462702&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v4-4-85037067.first_rank_ecpm_v3_pc_rank_v4&amp;utm_term=vue</a><br>
<a href="https://blog.csdn.net/lishanleilixin/article/details/79360244?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase">https://blog.csdn.net/lishanleilixin/article/details/79360244?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase</a><br>
##1.Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。<br>
这里渐进式框架也就是上边vue特点中的灵活一项，使用vue，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；</p>
<p>比如说刚开始用数据绑定做一个表单，后来控制整个页面的dom，再后来用router控制路由做单页应用，组件配合，vuex与数据配合等等，使用vue，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用。</p>
<p>##2.Vue 只关注视图层， 采用自底向上增量开发的设计。<br>
视图层：<br>
那么HTML中的DOM其实就是视图，一个网页就是通过DOM的组合与嵌套，形成了最基本的视图结构，再通过CSS的修饰，在基本的视图结构上“化妆”让他们看起来更加美观。最后涉及到交互部分，就需要用到JavaScript来接受用户的交互请求，并且通过事件机制来响应用户的交互操作，并且在事件的处理函数中进行各种数据的修改，比如说修改某个DOM中的innerHTML或者innerText部分。</p>
<p>我们把HTML中的DOM就可以与其他的部分独立开来划分出一个层次，这个层次就叫做视图层。</p>
<p>MVVM是Model-View-ViewModel 的缩写，由 Model,View,ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。</p>
<p>##3.Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。<br>
响应的数据绑定：<br>
就是vue.js会自动响应数据的变化情况，并且根据用户在代码中预先写好的绑定关系，对所有绑定在一起的数据和视图内容都进行修改。而这种绑定关系，在图上是以input 标签的v-model属性来声明的，因此你在别的地方可能也会看到有人粗略的称vue.js为声明式渲染的模版引擎。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中的事务及使用]]></title>
        <id>https://song-2020.Github.io/post/java-zhong-de-shi-wu-ji-shi-yong/</id>
        <link href="https://song-2020.Github.io/post/java-zhong-de-shi-wu-ji-shi-yong/">
        </link>
        <updated>2020-07-06T01:39:37.000Z</updated>
        <summary type="html"><![CDATA[<p>https://blog.csdn.net/weixin_37934748/article/details/82774230</p>
]]></summary>
        <content type="html"><![CDATA[<p>https://blog.csdn.net/weixin_37934748/article/details/82774230</p>
<!-- more -->
<p>什么是事务？</p>
<p>事务（Transaction），一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言（如SQL，C++或Java）书写的用户程序的执行所引起，并用形如begin transaction和end transaction语句（或函数调用）来界定。事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。</p>
<p>为什么要事务？</p>
<p>事务是为解决数据安全操作提出的，事务控制实际上就是控制数据的安全访问。</p>
<p>用一个简单例子说明：银行转帐业务，账户A要将自己账户上的1000元转到B账户下面，A账户余额首先要减去1000元，然后B账户要增加1000元。假如在中间网络出现了问题，A账户减去1000元已经结束，B因为网络中断而操作失败，那么整个业务失败，必须做出控制，要求A账户转帐业务撤销。这才能保证业务的正确性，完成这个操走就需要事务，将A账户资金减少和B账户资金增加放到同一个事务里，要么全部执行成功，要么全部撤销，这样就保证了数据的安全性。</p>
<p>事务的4个特性（ACID）：</p>
<ol>
<li>
<p>原子性（atomicity）：事务是数据库的逻辑工作单位，而且是必须是原子工作单位，对于其数据修改，要么全部执行，要么全部不执行。</p>
</li>
<li>
<p>一致性（consistency）：事务在完成时，必须是所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。（实例：转账，两个账户余额相加，值不变。）</p>
</li>
<li>
<p>隔离性（isolation）：一个事务的执行不能被其他事务所影响。</p>
</li>
<li>
<p>持久性（durability）：一个事务一旦提交，事物的操作便永久性的保存在DB中。即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
</li>
</ol>
<p>Java有几种类型的事务？</p>
<p>Java事务的类型有三种：JDBC事务、JTA（Java Transaction API）事务、容器事务。<br>
————————————————<br>
版权声明：本文为CSDN博主「share_happy_life」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/weixin_37934748/article/details/82774230</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java面试题相关]]></title>
        <id>https://song-2020.Github.io/post/java-mian-shi-ti-xiang-guan/</id>
        <link href="https://song-2020.Github.io/post/java-mian-shi-ti-xiang-guan/">
        </link>
        <updated>2020-07-06T01:15:01.000Z</updated>
        <content type="html"><![CDATA[<p>1、都用过哪些技术和框架？<br>
2、在项目中主要干一块，用了哪些技术？<br>
3、设计模式了解吗，都会哪些设计模式？<br>
单例模式，模板模式，策略模式<br>
4、在项目中常用到哪几个？<br>
5、说一下工厂模式，都有哪几种，有什么区别。<br>
简单工厂：可以造很多种汽车品牌的车子，<br>
工厂：只关心结果，隐藏复杂的过程，<br>
方法：约束<br>
抽象：简单工厂和方法工厂的结合<br>
6、用过PpringCloud吗？说一下有哪些组件。<br>
7、JVM调优会吗，都调过什么参数？<br>
8、数据库用的多吗，平常都怎么用的？<br>
9、Java的事务有几种说一下？<br>
JDBC事务、JTA（Java Transaction API java事务接口）事务、容器事务。<br>
10、数据库的事务呢？<br>
11、脏读、幻读、不可重复读说一下。<br>
脏读指一个事务读取了另外一个事务未提交的数据。<br>
不可重复读指在一个事务内读取表中的某一行数据，多次读取结果不同。<br>
不可重复读和脏读的区别是，脏读是读取前一事务未提交的脏数据，不可重复读是重新读取了前一事务已提交的数据。<br>
虚读(幻读)是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。<br>
12、平常在项目中事务怎么处理的，我们这边数据库操作比较多。<br>
spring boot   AOP<br>
好的，今天面试到此结束，待会叫HR将反馈信息告知你。</p>
<p>老说我的面经简单，来一个正常的了！！！！<br>
--------------背景--------------<br>
创业型公司，有自研的校园社区类复合型APP。现场面试，先笔试题，然后再面试问了一些，共一轮复合型面试。<br>
能不能建议各互联网公司给一台没有网络的电脑笔试，天天摸电脑不怎么写字手都要断了，而且问题太宽泛空地不够写啊，写得慢没写完还没嫌弃了。<br>
--------------过程---------------<br>
本次就一轮笔试+面试，先做题，然后自我介绍，再就问了几个问题。<br>
--------------笔试题---------------<br>
一、String、StringBuilder、StringBuffer它们之间的区别，他们有哪些常用操作方法？<br>
二、Spring有哪些特性，以及他们的原理是什么？SpringMvc工作流程大概描述一下。<br>
三、Mybatis框架运行原理大概描述一下。<br>
四、Java集合类有哪些，描述下他们的区别。<br>
五、线程池的运行原理描述一下。<br>
六、MySql的运行原理，MySql中两种引擎有什么区别。<br>
七、索引是什么，有什么作用？描述下它的原理。<br>
八、查询中的左连接、右连接、内连接<br>
九、乐观锁和悲观锁<br>
十、事务有几大特性，说出它们代表的意思，并描述一下并发事务隔离级别。<br>
十一、GC是什么，GC算法都有什么？<br>
十二、说说什么是缓存，应用场景和注意事项<br>
十三、MQ是什么，应用场景和注意事项<br>
--------笔试实操题---------<br>
十四、使用ArrayList来实现一个排序。仅能使用一个ArrayList，一个courseList，course记录了分数score、课程name，实现一个对courseList以分数高低排序的方法。<br>
十五、统计。若假设course表有课程分数字段course，有1、2分的课程，如何使用一句sql语句进行统计有多少门1分课程和2分课程（面试官建议使用group by）。<br>
十六、设计数据库。设计一套权限数据库，用户可以有多个角色，可以对角色进行授权，设计完毕使用一条sql语句，把指定id的用户的权限集查出来。<br>
十七、代码质量保证。如何做好单元测试、集成测试？如何保证交付代码的质量，描述一下你的方式方法。<br>
------------------面试题-----------------<br>
一、先介绍一下你自己。<br>
二、说一下你在项目主要负责的模块，最近一次你自己开发模块的整体流程。<br>
三、描述下项目中整个开发流程的参与程度，需求设计参与了吗，怎么参与的，后期开发呢。<br>
四、拿到需求后如何去开发、如何搭建，需要项目经理配合吗，怎么配合？编码过程代码质量由自己全权掌控吗？<br>
五、说说索引吧，还有原理。<br>
六、数据库中乐观锁、悲观锁用操作具体怎么实现的?<br>
七、前端会吗，需要自己开发页面吗，会到什么程度？<br>
八、高并发经验有吗，死锁怎么定位？<br>
九、有什么想要问的？<br>
十、你学习成绩怎么样？<br>
答：中上等，不算顶尖。（内心OS：？？？？，这不是应届才问？我都毕业好多年了）</p>
<p>--------------背景--------------<br>
金融类公司。在线面试，就突然收到笔试邮件，两天内登陆，限时150分钟，有4道算法题，一些单选题，多选题、填空题、简答题，共计50个。需要开启摄像头，不许切出全屏答题页面。<br>
--------------过程---------------<br>
不知道有几次，我猜测笔试过了应该再面试；HR也没联系我就直接发了一个笔试邮件，先做了再说，不然今天就超时了。简历投的太多也不知道具体是哪一家公司了。题也比较多，做完只能记住一些大概了。<br>
--------------笔试题---------------<br>
单/多选题忘了题目了共计20+道，大概范围是java基础、spring（原理以及一些注解）、mybatis、mysql、事务；docker有两道。<br>
填空题，10题左右，例如：<br>
1.Java定义整形变量的关键字，四个空<br>
2、mybatis有哪两种事务机制<br>
3、只有满足条件的记录才会包含在查询记录中，是什么连接？<br>
4、JPA的Entity自定义主键测试使用哪个注解？<br>
5、Docker，指定容器名称、ip，端口，映射本地主机端口的操作命令怎么写。<br>
简答题：<br>
1、Spring中IOC、AOP是什么意思，它们的原理是什么<br>
2、Spring中bean的生存周期<br>
3、使用（A,B,C）组合索引作为组合索引，（C）能生效吗，怎样的查询能生效。<br>
4、Java内存分配策略<br>
5、比较栈和队列<br>
6、hashmap的原理<br>
算法题4道：<br>
1）找出两个链表共同的元素头，有则返回当前节点值，没有返回null，比如1-2-3 ； 2-7；那么即为2。<br>
2）给定数组int[],求出其中的最大值。<br>
3）求出1-n中的质数<br>
4）输入一串字符串例如abc，输出其中字符可能的字符串，例如abc、acb、bac、bca、cab、cba。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java练习题]]></title>
        <id>https://song-2020.Github.io/post/java-lian-xi-ti/</id>
        <link href="https://song-2020.Github.io/post/java-lian-xi-ti/">
        </link>
        <updated>2020-07-03T01:10:51.000Z</updated>
        <content type="html"><![CDATA[<p>第一部分  选择题（单选）<br>
1.javac 是 Java 的 (  )。 B<br>
A. 解释器 B. 编译器 C. 小程序浏览器 D. 调试器<br>
2. appletviewer 是 Java 的 (  )。 C<br>
A. 解释器 B. 编译器 C. 小程序浏览器 D. 调试器<br>
3.编译一个定义了三个类和三个方法的 Java 源码文件，总共会产生几个字节码文件，其扩展名是什么？(  ) C<br>
A. 5 个字节码文件，其扩展名是”.java”。B. 2 个字节码文件，其扩展名是”.java”。<br>
C. 3 个字节码文件，其扩展名是”.class”。D. 2 个字节码文件，其扩展名是”.class”。<br>
4.Java 源码文件的名称与主类的名称(  )。B<br>
A. 必须相同但不区分大小写 B. 必须相同且区分大小写 C. 必须不同 D. 任意<br>
5.下面哪些选项不能用作变量名的首字符？（  ）C<br>
A. 字母 B. 下划线(<em>)C. 数字 D. 美元符($)<br>
6.下面哪个不是 Java 的原始数据类型？（  ） C<br>
A. shortB. boolean  C. IntD. float<br>
7.下面哪条语句不会出现编译警告或错误？（  ） A<br>
A. float f=1.3F;B. char c=”a”;C. float f=1.3;D. boolean d=null;<br>
8.以下声明常量不正确的是（  ） 。 B<br>
A. final int PI=3;B. final PI=3;C. static final int PI=3;D. public static final int PI=3;<br>
9.Java 定义了 4 个整型数据类型：字节型（byte） 、短整型（short） 、整型（int） 、长整型（long） ，其中 byte 占用内存为 A<br>
A. 8 bitB. 16 bitC. 32 bitD. 64 bit<br>
10.5%2.1 的值是(  )。 C<br>
A. 1 B. 0 C. 0.8 D. 不能通过编译<br>
11. -11&amp;3 的值是(  )。 A<br>
A. 1 B. 3 C. 9 D. -11<br>
12..8&lt;&lt;2 值是(  )。 D<br>
A. 2 B. 4 C. 8  D. 32<br>
13.若有 int a=1,b=2,c=3,d=4;，则表达式 a&gt;b ? a:c&gt;d ? c:d 的值是(  )。D<br>
A. 1 B. 2 C. 3 D. 4<br>
14.以下为合法类型转换的为（  ） 。 D<br>
A. (int)”A”B. (char)”A”C. (boolear)(2-2)D. (char)(651/12)<br>
15.下面哪条语句是正确的？（  ）C<br>
A. int a={1,2,3,4,5};B. int b=(1,2,3,4,5);C. int c[]={1,2,3,4,5};D. int []d={1 2 3 4 5};<br>
16.对于数组 int a[];下面哪条语句可以输出数组 a 的元素的个数？ D<br>
A. System.out.println(a.size);B. System.out.println(a.size( ));<br>
C. System.out.println(a.length());D. System.out.println(a.length);<br>
17. 可以用作 switch 表达式的基本数据类型分别是（  ） 。B<br>
A. Boolean  B. byte  C. float D. double<br>
18.下面的 while 语句退出时， i 的值是（  ） 。C<br>
byte b=1;int i=0; while(b++&gt;0) i=i+1;<br>
A. 126 B. 0 C. 127 D. 出现死循环，i 的值为无穷大。<br>
19.设 J_Hello.java 文件内容如下：<br>
class J</em> Hello { static void main(String args[]){   System.out.println(“Hello!”); }}<br>
下面正确的说法是： （  ） B<br>
A. J_Hello.java 无法通过编译。<br>
B. J_Hello.java 可以通过编译，但运行时出现”Main method not public”提示信息。<br>
C. J_Hello.java 可以通过编译，但无法运行，且无任何提示信息。<br>
D. J_Hello.java 可以通过编译，可以正常运行，输出”Hello!。<br>
20.下面哪个类声明是正确的。 （  ） D<br>
A. abstract final class car{} B. abstract private car(){}<br>
C. protected private car{} D. public abstract class car{}<br>
21.下列（  ）的说法是错误的。 C<br>
A. Java 语言只允许单一继承 B. Java 语言允许多个接口<br>
C. Java 语言不允许一个类派生多个子类 D. Java 语言的单一继承使得代码更加可靠<br>
22.下述（  ）说法是正确的。 A<br>
A. 实例变量是类的成员变量 B. 实例变量是用 static 关键字声明的<br>
C. 方法变量在方法执行时创建 D. 方法变量在使用之前不用初始化<br>
23.使用继承的优点是（  ） A<br>
A. 基类的大部分功能可以通过继承关系自动进入派生类 B. 继承将基类的实现细节暴露给派生类<br>
C. 一旦基类实现出现问题，就会影响到派生类 D. 可在运行期决定是否选择继承代码，有足够的灵活性<br>
24.下列关于修饰符混用的说法，错误的是（  ） 。 D<br>
A. abstract 不能与 final 并列修饰同一个类 B. abstract 类中不能有 private 的成员<br>
C. abstract 方法必须在 abstract 类中 D. static 方法中能处理非 static 的属性<br>
25.对于下列代码：<br>
public class Parent<br>
{ public int addValue(int a,int b)  {int s;s=a+b; return s;}}class Child extends Parent {…}<br>
Child 类中欲把 Parent 类中的 addValue 方法覆盖，下述什么方法可以加入类 Child 中？（  ） C<br>
A. private int addValue(int a,int b){…}    B. public float addValue(int a,int b){…}<br>
C. public int addValue(int a,int b){…}     D. public int addValue(int a,int b)throws MyException{…}<br>
26.声明成员变量为临时变量（又称为过渡变量）所用的保留字是（  ） 。 C<br>
A. final B. Abstract C. Transient D. temp<br>
27.声明公共变量所用的保留字是（  ） 。 A<br>
A. public B. private C. protected D. static<br>
28.声明受保护变量所用的保留字是（  ） 。C<br>
A. public B. private C. protected D. static<br>
29.设有下面的程序段：</p>
<ol>
<li>class StaticStuff</li>
<li>{</li>
<li>static int x=10;</li>
<li>static {x+=5;}</li>
<li>public static void main(String args[])</li>
<li>{</li>
<li>System.out.println(“x=”+x);</li>
<li>}</li>
<li>static {x/=3;}</li>
<li>}<br>
哪个说明是正确的是（  ） 。 C<br>
A. 4 行和 9 行不能通过编译，因为缺少方法名和返回类型 B. 9 行不能通过编译，因为只能有一个静态初始化器<br>
C. 编译通过，执行结果为：x=5  D. 编译通过，执行结果为：x=3<br>
30.对于下述类定义哪个说法正确？（  ） D<br>
class MyString extends String{…}<br>
A. 可以成功编译        B. 无法编译，因为没有 main 方法<br>
C. 无法编译，因为 String 是抽象类      D. 无法编译，因为 String 是 final 类<br>
31.不能在 Java 派生类中被覆盖的方法是（  ） 。 C<br>
A. 构造函数 B. 动态方法 C. final 方法 D. 抽象方法<br>
32.关于方法覆盖，下面哪个说法是错误的？（  ） A<br>
A. 方法覆盖可以发生在任意类之间。B. 覆盖方法与被覆盖的方法返回值类型相同。<br>
C. 如果被覆盖的方法是用 public 修饰的，覆盖方法也必须用 public 修饰。<br>
D. 覆盖方法不能抛出比被覆盖的方法更多的异常。<br>
33.下面哪个方法声明是正确的？（  ） C<br>
A. abstract final String abc(){ }B. public abstract abc(){ }<br>
C. private static void abc(){ }D. public abstract static void abc(){ }<br>
34.编译以下代码，将出现什么情况？（  ） B<br>
abstract class Shape{  abstract void draw();}class Square extends Shape{ }<br>
A. Square 类和 Shape 类都可以成功编译 B. Square 类无法编译，但 Shape 可以编译<br>
C. Shape 类无法编译，但 Square 但可以编译 D. Square 类和 Shape 类都无法编译<br>
35.关于 Java 的垃圾回收机制，下面哪些结论是正确的？（  ） B<br>
A. 程序可以任意指定释放内存的时间 B. 正确的程序写法是不能依赖垃圾回收的时间或者顺序<br>
C. 程序不能标识某个局部变量的引用不再被使用 D. 程序可以显示地立即释放对象占有的内存<br>
36.要求设计一个类，它拥有一个特殊的成员域，该成员域必须能够被这个类的子类访问到，但是不能被不在同一个包内的其它类访问到，下面哪些设计可以满足上述要求？（  ） C<br>
A. 该成员域的封装属性设置为 public       B. 该成员域的封装属性设置为 private<br>
C. 该成员域的封装属性设置为 protected      D. 该成员域不需要特殊的封装属性<br>
37.接口的实现所用的关键字是（  ） 。 B<br>
A. interface B. implements      C. extends     D. throws<br>
38.在编写异常处理的 Java 程序中，每个 catch 语句块应该与什么语句块对应？（  ）C<br>
A. if-else    B. Switch      C. Try    D. throw<br>
39.在编写 Java Application 程序时，若需要使用到标准输入/输出语句，必须在程序的开头写上什么语句？（  ） C<br>
A. import java.awt.<em>;    B. import java.applet.Applet;<br>
C. import java.io.</em>;     D. import java.awt.Graphics;<br>
40.下面哪个类最适合处理大数据量的文本文件？（  ） C<br>
A. java.io.FileInputStream  B. java.io.FileReaderC. java.io. BufferedReader    D. java.io.RandomAccessFile<br>
41.以下什么类不属于字符流类？（  ） C<br>
A. Reader  B. FileReader   C. BufferedInputStream  D. StringReader<br>
42.在设计 Java 的数据流操作的程序中，必须加入什么语句？（  ） C<br>
A. import java.awt.<em>;   B. import java.applet.</em>;   C. import java.io.<em>;  D. import java.awt.event.</em>;<br>
43.以下哪个可能包含菜单条？（  ） B<br>
A. Panel B. Frame C. Applet D. Dialog<br>
44.以下代码完成画线功能，指出所画线的颜色。 （  ） D<br>
g.setColor(Color.red.green.yellow.cyan);g.drawLine(0,0,100,100);<br>
A. red  B. green  C. yello  D. cyan<br>
45.Thread 类的什么方法实现线程的暂时停止操作？（  ） D<br>
A. destroy() B. stop() C. sleep() D. suspend()<br>
46.处理线程间通信等待和通知的方法是（  ） 。 A<br>
A. wait()和 notify() B. start()和 stop() C. run()和 stop() D. wait()和 suspend()<br>
47.在 Java 中，开发图形用户界面的程序需要使用系统提供的类库，这个类库是（  ） 。 B<br>
A. java.io B. java.awt C. java.appletD. java.awt.event<br>
48.applet 所在的页面被浏览和加载后，applet 就诞生了。当浏览器切换到别的页面时，它的什么方法被调用？（  ） C<br>
A. init B. Start C. Stop  D. destroy<br>
49.标签组件由什么类生成（  ） 。 A<br>
A. Label    B. Button     C. Choice     D. Checkbox<br>
50．画矩形，使用什么方法？（  ） B<br>
A. drawLing(x1,y1,x2,y2) B. drawRect(x1,y1,w,h) C. drawOval(x1,y1,w,h) D. drawString(s,x1,y1)<br>
51.Java 是什么公司推出的一种面向对象的现代程序设计语言？ (  ) A<br>
A. SUN 公司 B. Borland 公司 C. IBM 公司 D. Microsoft 公司<br>
55.设 x=1，y=2，z=3，则表达式 y+=z++/x--的值是(  )。 D<br>
A. 3  B. 3.5  C. 4  D. 5<br>
56.11&amp;-3 的值是(  )。 C<br>
A. 1 B. 3 C. 9 D. -11<br>
57.下面哪条语句是正确的？（  ） C<br>
A. int []a1=new double[3[;  B. int a2[][]=new double[];  C. int a3[][]={{1},{1,2},{1,2,3}};<br>
D. int a4[3]={1.0,2.0,3.0};</li>
<li>为 AB 类的一个无形式参数的方法 method 书写方法头，使得使用类名 AB 作为前缀就可以调用它，该方法头的形式为（  ） 。 A<br>
A. static void method() B. public void method() C. final void method() D. abstract void method()<br>
65.在 Java Applet 程序用户自定义的 Applet 子类中，一般需要重载父类的什么方法来完成主类实例的初始化工作。 C<br>
A. start()B. stop() C. init() D. paint()<br>
第二部分  填空题<br>
1.Sun 公司提供的 Java 开发工具包，用于台式机的开发工具包是   JDK       。<br>
2.Java 程序可分为两种基本类型，它们是  基本数据类型    和  复合数据类型   。<br>
3.Java 虚拟机运行 Java 程序的基本步骤是： 首先从后缀为 .java   的文件加载代码到内存中， 接着在内存中  检查       代码的合法性及安全性，然后  顺序      执行安全和合法的代码。<br>
4.Java 标识符是由 字母数字下划线美元符    组成的字符序列。<br>
5.Java 字符（char）采用的是 ISO 规定的  unicode      字符集。<br>
6.int 类型数据在内存中占  4   个 2 进制位。</li>
<li>在 Java 语言中，字符串直接量是用  “”        括起来的字符序列。<br>
8.字符串不是字符数组，而是类  实例化       的实例对象。<br>
9.在类中声明的变量叫   属性        ,可在  类      中使用。<br>
10.在方法和方法块中声明的变量叫局部变量 ,其使用范围是  方法中   。<br>
11.byte 或 short 或 int 类型数据与 long 类型数据混合运算时，其结果是 long     类型.<br>
12.设 x=2，则表达式(x++)/3 的值是  0    。<br>
13.设 x=5，y=10, 则表达式 x&gt;y&amp;&amp;x++==y--的值是 false     。<br>
14.设有运算符!=、*、&amp;&amp;、&gt;=、？：按优先级从高到低的排列顺序是 * != &gt;= &amp;&amp; ? :  。<br>
15.表达式(3&lt;5)^(6&lt;4)的值是 true     。<br>
16.表达式(byte)(1200) 的值是 -80     。<br>
17.数组对象的长度在数组对象创建之后，就不能      改变。<br>
18.已知数组 a 的定义是“int a[]={1,2,3,4,5};”则这时 a[2]的值是 3    。<br>
19.如有声明 float a[][]=new float[3][4];则系统为该数组分配 12 个字节的空间。<br>
20.对于数组 int [][]t={{1,2,3,4},{5,6,7,8}};，t.length 等于2   ，t[0].length 等于   4  。<br>
21.switch 语句中的 case 后面的常量可以是 byte   short  类型、和 int      类型,<br>
22.若有 byte b=1;int i=0; while(++b&gt;0) i=i+1;，则 while 退出时 i 的值为 126      。<br>
23.面向对象的计算机语言一般应有 3 个基本特征，分别是 封装 、继承   和多态  。<br>
24.如果一个 Java Applet 源程序文件只定义有一个类，其类名为 MyApplet，则类 MyApplet 必须是 Applet       类的子类<br>
25.一个复杂的系统往往包含多个对象，这些对象间可能存在的关系有三种，它们是 继承       、   聚合     和  关联       。</li>
<li>抽象   方法是一种仅有方法头，没有具体方法体个操作实现的方法，该方法必须在抽象类中定义。</li>
<li>final       方法是不能被当前类的子类重新定义的。<br>
28.Java 语言通过 垃圾回收 机制简化了程序的内存管理。<br>
29.在 Java 中有两种多态，一种是使用方法的 重载 实现多态，另一种是使用方法的         重写 实现多态。<br>
30.由 protected 修饰的变量称为  受保护变量   ，可被 包内和包外子类中    访问。<br>
31.抽象方法是指 只有声明没有实现   的方法，抽象方法只能出现在  抽象类       中。<br>
32．.在 Java 类的层次结构中，最顶端的类是 Object   ，它在 java.lang包   中定义，是所有类的始祖。<br>
33.不能覆盖父类中的  final  方法和  private       方法。<br>
34.创建子类对象实例时，系统可以自动调用父类的 无参  构造方法，初始化属性                的数据。</li>
<li>对于父类中的构造方法，系统不能自动调用它们，只能通过在子类构造方法中使用关键字  super      调用， 其调用语句位置必须是 方法中可执行语句的第一句 。<br>
36.创建一个名为 MyPackage 的包的语句是  package MyPackage;   ，该语句应该放在程序的位置为：第一句         。<br>
37.Java 提供的异常处理机制包括两个过程 捕获      和  处理     。<br>
38.在 Java 程序中，通过接口的定义可以实现 多      重继承关系。<br>
39.顺序执行以下两条语句的输出结果是：3 。String s=”沈阳市”;System.out.println(s.length());<br>
40.字符串分为两大类，一类是字符串常量，使用 String  类的对象表示；另一类是字符串变量，使用 StringBuffer   类的对象表示。<br>
41.创建一个标识有“关闭”按钮的语句是 JButton button=new JButton(“关闭”)。<br>
42.Java 的组件主要在 JFrame         和 JPanel         中。<br>
43.线程创建后，可以在任何时刻调用  setPriority          方法改变线程的优先级。<br>
44.调用  stop      方法可以停止线程的运行。<br>
45.applet 所在的页面被浏览和加载后，applet 就诞生了。当浏览器切换到别的页面时，它的  stop      方法被调用。<br>
46.标签组件由 JLabel      类生成。<br>
47.画矩形的方法是  drawRect  。<br>
48.关键字 synchronized 的作用是  同步   。<br>
49.wait()方法与 notify()或 notifyAll()方法只能用在   同步        方法中。<br>
50.当线程对象被调度执行时自动调用 run 方法。<br>
58.多态是指接口的多种不同的实现方式。<br>
第三部分  回答问题<br>
1.上机编译编写的源程序，使用什么命令进行编译？源程序文件的扩展名是什么？Java 编译器产生的文件扩展名是什么？<br>
2.上机解释执行编译好的程序，使用什么命令进行解释？Java 解释器解释的文件的扩展名是什么？<br>
3.简述 Java 语言的主要特点。<br>
4．Java 应用程序和 Java 小应用程序有何区别？<br>
5.Java 能跨操作系统平台运行的原理是什么？<br>
6.简述 Java 程序的框架结构。<br>
7.float 和 double 型数据在赋值时有哪些注意事项？<br>
8.float 和 double 型数据在赋值时有哪些注意事项?<br>
9.Java 为什么把字符串定义为类？为什么定义了两个字符串类？<br>
10.静态变量有何特点？如何存取静态变量？</li>
<li>静态方法有何特点？静态方法存取成员变量时有何要求？<br>
12.什么是抽象类、抽象方法？它们有什么特点？<br>
13.类与对象有何关系？如何创建对象？<br>
14.什么是类变量、成员变量、实例变量、局部变量？<br>
15.什么是类的多态性？何为隐藏、覆盖、重载？<br>
16.this 和 super 有什么作用？<br>
17.什么是构造方法？构造方法有何特点和作用？<br>
18.设 Object 类派生出 G 类，G 类派生出 F 类，F 类派生出 Me 类。<br>
问：①构造器的调用顺序是什么。？<br>
②如果父类的构造器重载了，可通过什么方法调用父类中某个指定的构造器？<br>
③如果子类自己的构造器重载了，可通过什么方法在一个构造器中调用另一个构造器？<br>
19.什么是标准输入输出方法？什么是标准输入输出设备？标准输入方法read在使用中应注意什么？它输入的数据是什<br>
么类型？<br>
20．包有什么作用？Java 系统提供了哪些常用包？如何使用包？<br>
21．接口有什么作用？接口有哪些性质？<br>
22．什么是异常？为什么要进行异常处理？如何创建一个自定义异常？如何抛出自定义异常？<br>
23． 试述 Java Applet 的工作原理，其生命周期是如何划分的？<br>
24．如何从 HTML 文件中向 Applet 传递参数？这些参数是如何被接收和处理的？</li>
</ol>
<p>7<br>
25.什么是 Java 数据流？<br>
26.简述 Java 虚拟机的执行过程。<br>
27.Java 为什么把字符串定义为类？为什么定义了两个字符串类？<br>
28.什么是构造方法？构造方法有何特点和作用？<br>
29．试述 Java Applet 的工作原理，其生命周期是如何划分的？</p>
<p>第四部分  写出下面程序的运行结果或完成的功能（以下各程序请自己上机通过，得出结果。 ）<br>
1.public class sum{<br>
public static void main(String args[]){<br>
double sum=0.0;<br>
for(int i=1;i&lt;=100;i++)<br>
sum+=1.0/(double)I;<br>
System.out.println(“sum=”+sum);<br>
}<br>
}<br>
2.public class J_Test7{<br>
public static void main(String args[]){<br>
int i=1,x=2;<br>
switch(x){<br>
case 1:i++;<br>
case 2:i--;<br>
case 3:++i;break;<br>
case 4:--i;}  System.out.println(i); }}<br>
3.class Q1{<br>
public static void main(String args[]){<br>
double d=5.55;<br>
Dec dec=new Dec();<br>
dec.decrement(d);<br>
System.out.print(d);<br>
}<br>
}<br>
class Dec{<br>
public void decrement(double decMe){<br>
decMe= decMe-1;<br>
}<br>
}<br>
4.使用命令 java abc Good Moning 运行下面程序，问输出<br>
什么？<br>
public class abc{<br>
public static void main(String args[]){<br>
Charger c=new Charger();<br>
c.method(args);<br>
System.out.print(args[0]+” “+args[1]);<br>
}<br>
}<br>
class Charger{<br>
void method(String[] s){<br>
String temp=s[0];<br>
s[0]=s[1];<br>
s[1]=temp;<br>
}<br>
}<br>
5.设有如下程序：<br>
public class J_Test9{</p>
<p>public static void main(String args[]){</p>
<p>int sum=0;</p>
<p>a:  for(int i=1;i&lt;12;i++) {</p>
<pre><code>for(int j=1;j&lt;4;j++) { 

 sum+=j; 

 if(i+j&gt;5) break a; } 
</code></pre>
<p>}</p>
<p>System.out.println(&quot;sum=&quot;+sum);<br>
}</p>
<p>}<br>
6．class J_Base<br>
{<br>
public void mb_method()<br>
{<br>
System.out.println(&quot;Base&quot;);<br>
}<br>
}<br>
class J_Test15 extends J_Base<br>
{<br>
public void mb_method()<br>
{<br>
System.out.println(&quot;Test&quot;);<br>
}<br>
public static void main(String args[])<br>
{<br>
Object a=new J_Test15();<br>
((J_Base)a).mb_method();<br>
}<br>
}<br>
7．public class J_Test16<br>
{<br>
static int m_data=0;<br>
public int mb_method()<br>
{<br>
m_data++;</p>
<p>8<br>
return m_data;<br>
}<br>
public static void main(String args[])<br>
{<br>
J_Test16 a=new J_Test16();<br>
J_Test16 b=new J_Test16();<br>
J_Test16 c=new J_Test16();<br>
a.mb_method();<br>
b.mb_method();<br>
c.mb_method();<br>
int i=a.mb_method();<br>
System.out.println(i);<br>
}<br>
}<br>
8． public class J_Test17<br>
{<br>
int m_i=2;<br>
String m_s=null;<br>
J_Test17()<br>
{<br>
m_i=2;<br>
m_s=&quot;record&quot;;<br>
}<br>
public static void main(String args[])<br>
{<br>
J_Test17 app=new J_Test17();<br>
System.out.println(app.m_i+app.m_s);<br>
}<br>
}</p>
<p>9.public class abc{<br>
public static void main(String args[]){<br>
SubClass sb=new SubClass();<br>
System.out.println(sb.max());<br>
}<br>
}<br>
class SuperClass{<br>
int a=10,b=30;<br>
}<br>
class SubClass extends SuperClass{<br>
int max() {return((a&gt;b)? a:b);<br>
}<br>
}<br>
10class J_Base{<br>
public int m_data=6;<br>
public void mb_print()<br>
{<br>
System.out.print(m_data);<br>
}<br>
}<br>
class J_SubClass extends J_Base{<br>
public int m_data=3;<br>
public void mb_print()<br>
{<br>
System.out.print(m_data);<br>
}<br>
}<br>
class J_Test{<br>
public static void main(String args[]){<br>
J_Base app=new J_SubClass();<br>
app.mb_print();<br>
System.out.println(app.m_data);<br>
}<br>
}<br>
11.class Parent{<br>
void printMe()<br>
{System.out.println(“parent”);}<br>
}<br>
class Child extends Parent{<br>
void printMe()<br>
{System.out.println(“child”);}<br>
void printAll()<br>
{<br>
super.printMe();<br>
this. printMe();<br>
printMe();<br>
}<br>
}<br>
public class Test_this{<br>
public static void main(String args[]){<br>
Child myC=new Child();<br>
myC. printAll();<br>
}}<br>
12.import java.awt.*;<br>
public class St{<br>
public static void main(String args[]){<br>
String forwards=new String(“I love Java”);<br>
String backwards=” ”;<br>
System.out.println(forwards);<br>
int lastCharPos=( forwards.length()-1);<br>
int i;<br>
for(i= lastCharPos;i&gt;=0;i--)<br>
backwards+= forwards.charAt(i);<br>
System.out.println(backwards);<br>
}<br>
}</p>
<p>9<br>
13.class J_Base{<br>
public int m_data=1;<br>
public String mb_method()<br>
{return “2”;}<br>
}<br>
class J_Test extends J_Base{<br>
public int m_data=3;<br>
public String mb_method() {return “4”;}<br>
public static void main(String args[]){<br>
J_Base<br>
app=new<br>
J_Test();<br>
System.out.println(app.m_data+app.mb_method());<br>
}<br>
}<br>
14．public class H1{<br>
static int c;<br>
int a,b;<br>
public static void main(String[] s){<br>
int a=1,b=2,c=3;<br>
H1 h1=new H1();<br>
H1 h2=new H1();<br>
h1.a=4;<br>
h2.a=5;<br>
System.out.println(a);<br>
System.out.println(b);<br>
System.out.println(h1.a);<br>
System.out.println(h2.a);<br>
System.out.println(c);<br>
System.out.println(H1.c);<br>
}<br>
}<br>
15.abstract class V1{<br>
abstract int abc();<br>
}<br>
class E1 extends V1{<br>
int abc(){<br>
return 1;<br>
}<br>
}<br>
class H1{<br>
public static void main(String[] s){<br>
E1 e1=new E1();<br>
System.out.println(e1.abc());<br>
}<br>
}<br>
16.class H2{<br>
void ex(int[] y){<br>
for(int i=0;i&lt;y.length;i++)<br>
y[i]=y[i]+1;<br>
}<br>
}<br>
class H1{<br>
public static void main(String[] s){<br>
int[] x={1,2,3,4};<br>
for(int i=0;i&lt;x.length;i++)<br>
System.out.print(x[i]+&quot; &quot;);<br>
System.out.println();<br>
H2 h=new H2();<br>
h.ex(x);<br>
for(int i=0;i&lt;x.length;i++)<br>
System.out.print(x[i]+&quot; &quot;);<br>
}<br>
}<br>
17.class V1{<br>
int a=1;<br>
}<br>
class E1 extends V1{<br>
int b=2,c;<br>
void m1(){<br>
c=a+b;<br>
System.out.println(c);<br>
}<br>
}<br>
class H1{<br>
public static void main(String[] s){<br>
E1 e1=new E1();<br>
e1.m1();<br>
}<br>
}<br>
18.class V1{<br>
int a=1;<br>
}<br>
class E1 extends V1{<br>
int a=30,b=20,c;<br>
void m1(){<br>
c=a+b;<br>
System.out.println(c);<br>
} }<br>
class H1{<br>
public static void main(String[] s){<br>
E1 e1=new E1();<br>
e1.m1();<br>
}}<br>
19.class V1{<br>
int a=1;<br>
void m1(){<br>
System.out.println(&quot;V1.m1&quot;);</p>
<p>10<br>
} }<br>
class E1 extends V1{<br>
int a=3,b=2,c;<br>
void m2(){<br>
System.out.println(&quot;E1.m2&quot;);<br>
} }<br>
class H1{<br>
public static void main(String[] s){<br>
E1 e1=new E1();<br>
e1.m1();<br>
e1.m2();<br>
}}<br>
20.class V1{<br>
V1(){<br>
System.out.println(&quot;V1&quot;);<br>
}<br>
}<br>
class V2 extends V1{<br>
V2(){<br>
System.out.println(&quot;V2&quot;);<br>
}<br>
}<br>
class V3 extends V2{<br>
V3(){<br>
System.out.println(&quot;V3&quot;);<br>
}<br>
}<br>
class H1{<br>
public static void main(String[] s){<br>
V3 e1=new V3(); }}<br>
21.public class abc{<br>
public static void main(String args[]){<br>
int i.Max,Min;<br>
int a[]={12,67,8,98,23,56,124,55,99,100};<br>
Max=a[0];Min=a[0];<br>
for(i=1; i&lt;a.length;i++){<br>
if(a[i]&lt;Min) Min=a[i];<br>
if(a[i]&gt;Max) Max=a[i];<br>
}<br>
System.out.print(Max+” “+Min);<br>
}<br>
}<br>
22.设有如下程序：<br>
public class J_Test9{</p>
<p>public static void main(String args[]){</p>
<p>int sum=0;</p>
<p>for(int i=1;i&lt;10;i++) {</p>
<p>a:   for(int j=1;j&lt;3;j++) {</p>
<pre><code>  sum+=j; 

  if(i+j&gt;6) break a; } 
</code></pre>
<p>}</p>
<p>System.out.println(&quot;sum=&quot;+sum); }</p>
<p>}<br>
23.public class J_Test16<br>
{<br>
static int m_data=0;<br>
public int mb_method()<br>
{<br>
m_data++;<br>
return m_data;<br>
}<br>
public static void main(String args[])<br>
{<br>
J_Test16 a=new J_Test16();<br>
J_Test16 b=new J_Test16();<br>
J_Test16 c=new J_Test16();<br>
a.mb_method();<br>
b.mb_method();<br>
c.mb_method();<br>
int i=a.mb_method();<br>
System.out.println(i);<br>
}<br>
}<br>
24.class V1{<br>
V1(){<br>
System.out.println(&quot;V1&quot;);<br>
}<br>
}<br>
class V2 extends V1{<br>
V2(){<br>
System.out.println(&quot;V2&quot;);<br>
}<br>
}<br>
class V3 extends V2{<br>
V3(){<br>
System.out.println(&quot;V3&quot;);<br>
}<br>
}<br>
class H1{<br>
public static void main(String[] s){<br>
V3 e1=new V3();<br>
}<br>
}<br>
第五部分  程序设计</p>
<p>11</p>
<ol>
<li>编写一个字符界面的 Java Application 程序，输出 1~9 中除 6 以外所有偶数的平方值（即 2、4、8 的平方值） 。<br>
注：要求使用循环。</li>
<li>编写一个字符界面的 Java Application 程序，使用你熟悉的方法对数组 a[]={20,10,50,40,30,70,60,80,90,100}进行由大<br>
到小的排序。<br>
3.编写一个字符界面的 Java Application 程序，输出所有的水仙花数。<br>
注：水仙花数是一个 3 位数，它的各位数字的立方和等于这个 3 位数自身，如：153=13+53+33则 153 是水仙花数。<br>
4.编写一个字符界面的 Java Application 程序，输出 Fibonacci 序列的前 20 项。<br>
注：Fibonacci 序列定义如下：<br>
第 1 个数为 0<br>
第 2 个数为 1<br>
从第 3 个数开始，每个数是前两个数之和。<br>
如：0  1  1  2  3  5  8  13…<br>
5..设有如下类定义：<br>
public class Array{<br>
static int a[]=new int[5];<br>
int n=5;<br>
}<br>
①添加构造方法，对数组元素初始化。<br>
②设计一个对数组 a 中各元素求和的方法 sum，添加到类 Array 中。<br>
6.创建一个 Fraction 类执行分数运算，要求如下：<br>
①用整型数表示类的 private 成员变量：f1 和 f2。<br>
②提供构造方法，将分子存入 f1，分母存入 f1。<br>
③提供两个分数相加的运算方法，结果的分子存入 f1, 结果的分母存入 f2。<br>
④编写主控程序，实现分数相加运算。<br>
7.设类 Rectangle 定义如下：<br>
public class Rectangle{<br>
static int width,height;<br>
}<br>
在类 Rectangle 中添加两个方法，方法 girth 计算矩形周长，方法计算矩形 area 面积。<br>
8.编写一个日期类 Date，要求：<br>
①日期类 Date 属性有：<br>
year（int 型，代表年） 、month（int 型，代表月） 、day（int 型，代表日）<br>
②日期类 Date 的方法有：<br>
Date()：构造函数，日期默认初值为 2000 年 1 月 1 日。<br>
Date(int y,int m,int d)：构造函数，y、m、d 分别代表年、月、日。<br>
int GetYear()：获取日期的年份作为方法的返回值。<br>
int GetMonth()：获取日期的月份作为方法的返回值。<br>
int GetDayr()：获取日期的日作为方法的返回值。<br>
Void ShowDate()：以“****年<strong>月</strong>日”的形式显示一个日期，如：2001 年 8 月 13 日。<br>
9．编写程序，完成文件复制功能。<br>
10．设计一个 Applet 小程序，使其可以进行简单的加法运算。</li>
<li>编写一个字符界面的 Java Application 程序， 使用你熟悉的方法对数组 a[]={20,10,50,40,30,70,60,80,90,100}进行由大<br>
到小的排序。<br>
12.创建一个 Fraction 类执行分数运算，要求如下：<br>
①用整型数表示类的 private 成员变量：f1 和 f2。<br>
②提供构造方法，将分子存入 f1，分母存入 f1。<br>
③提供两个分数相加的运算方法，结果的分子存入 f1, 结果的分母存入 f2。<br>
④编写主控程序，实现分数相加运算。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[synchronized与volatile]]></title>
        <id>https://song-2020.Github.io/post/synchronized-yu-volatile/</id>
        <link href="https://song-2020.Github.io/post/synchronized-yu-volatile/">
        </link>
        <updated>2020-06-30T15:23:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="synchronized保证三大性原子性有序性可见性">synchronized保证三大性，原子性，有序性，可见性</h1>
<h1 id="volatile保证有序性可见性不能保证原子性">volatile保证有序性，可见性，不能保证原子性</h1>
<h1 id="volatile到底做了什么">volatile到底做了什么:</h1>
<p>禁止了指令重排<br>
保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量值，这个新值对其他线程是立即可见的<br>
不保证原子性（线程不安全）</p>
<h1 id="synchronized关键字和volatile关键字比较">synchronized关键字和volatile关键字比较：</h1>
<p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。<br>
多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞<br>
volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。<br>
volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。<br>
当一个变量定义为 volatile 之后，将具备两种特性：<br>
1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。<br>
2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。<br>
volatile 性能：<br>
volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>
<h1 id="为什么要使用synchronized">为什么要使用synchronized？</h1>
<p>在并发编程中存在线程安全问题，主要原因有：1.存在共享数据 2.多线程共同操作共享数据。<br>
关键字synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile。</p>
<h1 id="相关">相关</h1>
<p>synchronized关键字  : 用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这个段代码。可以对对象加互斥锁。<br>
volatile关键字：用来确保将变量的更新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。然而，在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比 synchronized关键字更轻量级的同步机制。</p>
<h1 id="所谓-volatile的措施就是">所谓 volatile的措施，就是</h1>
<ol>
<li>每次从内存中取值，不从缓存中什么的拿值。这就保证了用 volatile修饰的共享变量，每次的更新对于其他线程都是可见的。</li>
<li>volatile保证了其他线程的立即可见性，就没有保证原子性。<br>
3.由于有些时候对 volatile的操作，不会被保存，说明不会造成阻塞。不可用与多线程环境下的计数器。</li>
</ol>
<p>serialize：Java 对象序列化为二进制文件。<br>
static关键字： static关键字可以修饰变量，方法，静态代码块。<br>
静态变量:<br>
由static修饰的变量称为静态变量<br>
静态变量属于类，而不属于某个对象<br>
静态变量它的副本只有一个(静态变量在类中只加载一)<br>
静态方法：<br>
在静态方法中只能调用静态变量和静态方法<br>
在非静态方法中，可以调用静态方法或者变量。<br>
在静态方法中不能使用this和super关键字。<br>
静态代码块：<br>
作用:用来给静态成员变量初始化</p>
<p>关于原子性，有序性，可见性<br>
可见性：<br>
可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。<br>
可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。<br>
在 Java 中 volatile、synchronized 和 final 实现可见性。<br>
原子性：<br>
原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。<br>
在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。<br>
有序性：<br>
Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Object 类中方法及说明]]></title>
        <id>https://song-2020.Github.io/post/object-lei-zhong-fang-fa-ji-shuo-ming/</id>
        <link href="https://song-2020.Github.io/post/object-lei-zhong-fang-fa-ji-shuo-ming/">
        </link>
        <updated>2020-06-25T15:34:34.000Z</updated>
        <content type="html"><![CDATA[<p>registerNatives()   //私有方法<br>
getClass()    //返回此 Object 的运行类。<br>
hashCode()    //用于获取对象的哈希值。<br>
equals(Object obj)     //用于确认两个对象是否“相同”。<br>
clone()    //创建并返回此对象的一个副本。<br>
toString()   //返回该对象的字符串表示。<br>
notify()    //唤醒在此对象监视器上等待的单个线程。<br>
notifyAll()     //唤醒在此对象监视器上等待的所有线程。<br>
wait(long timeout)    //在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或        者超过指定的时间量前，导致当前线程等待。<br>
wait(long timeout, int nanos)    //在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。<br>
wait()    //用于让当前线程失去操作权限，当前线程进入等待序列<br>
finalize()    //当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring boot技术相关]]></title>
        <id>https://song-2020.Github.io/post/spring-boot-ji-zhu-xiang-guan/</id>
        <link href="https://song-2020.Github.io/post/spring-boot-ji-zhu-xiang-guan/">
        </link>
        <updated>2020-06-21T06:39:07.000Z</updated>
        <content type="html"><![CDATA[<p>#一、什么是 Spring Boot<br>
Spring Boot 是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简<br>
化是指简化了 Spring 众多框架中所需的大量且繁琐的配置文件，所以 Spring Boot 是一个服<br>
务于框架的框架，服务范围是简化配置文件。所以从本质上来说，Spring Boot 其实就是 Spring<br>
框架的另一种表现形式。</p>
<p>#二、 Spring Boot 特征<br>
1、使用 Spring Boot 可以创建独立的 Spring 应用程序<br>
2、在Spring Boot中直接嵌入了Tomcat、<br>
Jetty、Undertow等Web容器，所以在使用SpringBoot<br>
做 Web 开发时不需要部署 WAR 文件<br>
3、过提供自己的启动器(Starter)依赖，简化项目构建配置<br>
4、尽量的自动配置 Spring 和第三方库<br>
5、提供了生产就绪特征，如：度量指标，运行状况检查和外部化配置<br>
6、绝对没有代码生成，也不需要 XML 配置文件</p>
<p>#三、Spring Boot 的核心注解<br>
5.1@SpringBootApplication<br>
是 SpringBoot 的启动类。<br>
此注解等同于@Configuration+@EnableAutoConfiguration+@ComponentScan 的组合。<br>
5.2@SpringBootConfiguration<br>
@SpringBootConfiguration 注解是@Configuration 注解的派生注解，跟@Configuration<br>
注解的功能一致，标注这个类是一个配置类，只不过@SpringBootConfiguration 是 springboot<br>
的注解，而@Configuration 是 spring 的注解<br>
5.3@Configuration<br>
通过对 bean 对象的操作替代 spring 中 xml 文件<br>
5.4@EnableAutoConfiguration<br>
Spring Boot 自动配置（auto-configuration）：尝试根据你添加的 jar 依赖自动配置你的<br>
Spring 应用。是@AutoConfigurationPackage 和@Import(AutoConfigurationImportSelector.class)<br>
注解的组合。<br>
5.5@AutoConfigurationPackage<br>
@AutoConfigurationPackage 注解，自动注入主类下所在包下所有的加了注解的类<br>
（@Controller，@Service 等），以及配置类（@Configuration）<br>
5.6@Import({AutoConfigurationImportSelector.class})<br>
直接导入普通的类<br>
导入实现了 ImportSelector 接口的类<br>
导入实现了 ImportBeanDefinitionRegistrar 接口的类<br>
5.7@ComponentScan<br>
组件扫描，可自动发现和装配一些 Bean。<br>
5.8@ConfigurationPropertiesScan<br>
@ConfigurationPropertiesScan 扫描配置属性。@EnableConfigurationProperties 注解的作<br>
用是使用 @ConfigurationProperties 注解的类生效。</p>
<p>#四、Spring Boot 整合 Thymeleaf<br>
3.1Thymeleaf 介绍<br>
Thymeleaf 的主要目标是将优雅的自然模板带到开发工作流程中，并将 HTML 在浏览器<br>
中正确显示，并且可以作为静态原型，让开发团队能更容易地协作。Thymeleaf 能够处理<br>
HTML，XML，JavaScript，CSS 甚至纯文本。<br>
长期以来,jsp 在视图领域有非常重要的地位,随着时间的变迁,出现了一位新的挑战<br>
者:Thymeleaf,Thymeleaf 是原生的,不依赖于标签库.它能够在接受原始 HTML 的地方进行编<br>
辑和渲染.因为它没有与Servelet规范耦合,因此Thymeleaf模板能进入jsp所无法涉足的领域。</p>
<p>Spring Boot 整合mybatis框架<br>
MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
<p>generator插件<br>
可根据配置文件自动为mybatis项目生成mapper和pojo文件</p>
<p>spring boot热部署<br>
使用devtools或者jrebel工具</p>
<p>Spring Boot 度量指标监控与健康检查<br>
使用 Actuator 检查与监控<br>
使用可视化监控应用 Spring Boot Admin</p>
<p>#五、 关于Spring<br>
Spring是一系列轻量级Java EE框架的集合<br>
Spring中包含一个“依赖注入”模式的实现<br>
使用Spring可以实现声明式事务</p>
<p>Spring的三大核心IOC(控制反转)和DI(依赖注入)和AOP（面向切面编程），控制反转是将原先在代码中创建对象的工作交由spring容器管理。依赖注入采用动态代理的方式进行注入，注入方式可以通过构造函数、set方法、@Autowired注解注入。Spring的IOC和DI都是为了解除代码之间的耦合度，便于日后的项目扩展。举个栗子：在未使用spring之前，创建对象是通过在代码中通过new进行实例化的，假设我这里有一个Demo类，Demo类中有一个方法叫做getInfo() ,A、B、C、D类都有调用Demo类中的getInfo()，有一天公司小王不小心把Demo类中的getInfo()方法改动了，结果导致所有调用Demo类的getInfo()的类都报错了，直接项目项目跑不起来,通过上面可想而知为什么我们需要解除程序耦合，而spring的Spring IOC和DI就是为了解决这个问题的。另外就是对象生命周期的问题，以往大量创建的实例对象是在代码进行，如果对象资源不及时释放销毁很容易出现内存溢出异常。</p>
<p>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。<br>
轻量——从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。<br>
控制反转——Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。<br>
面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。<br>
容器——Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。<br>
框架——Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</p>
<p>spring没有提供AOP方式的日志系统。<br>
AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态***实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。<br>
Spring通过对AOP的支持，借助log4j等Apache开源组件实现了日志系统。</p>
<p>spring由哪些框架组成？<br>
spring context ,spring aop ,springMVC ,spring ORm ,spring web ,spring dao,core context</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[sleep、wait、yield、join]]></title>
        <id>https://song-2020.Github.io/post/sleepwaityieldjoin/</id>
        <link href="https://song-2020.Github.io/post/sleepwaityieldjoin/">
        </link>
        <updated>2020-06-20T15:26:59.000Z</updated>
        <content type="html"><![CDATA[<p>#1.sleep()方法<br>
在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。<br>
sleep()使当前线程进入阻塞状态，在指定时间内不会执行。<br>
#2.wait()方法  会使线程释放锁资源<br>
在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。<br>
当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。<br>
唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。<br>
waite()和notify()必须在synchronized函数或synchronized　block中进行调用。如果在non-synchronized函数或non-synchronized　block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。<br>
#3.yield方法<br>
暂停当前正在执行的线程对象。<br>
yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。<br>
yield()只能使同优先级或更高优先级的线程有执行的机会。<br>
#4.join方法   会使线程释放锁资源<br>
join()等待该线程终止。<br>
等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测</p>
<p>#总结<br>
yield方法：只是简单地对于CPU时间片的“礼让”，除非循环yield，否则一次yield，可能下次该线程仍旧可能会抢占到CPU时间片，可能方法调用和不调用没</p>
<p>#差别<br>
sleep是静态方法，针对当前线程，进入休眠状态，两个版本的sleep方法始终有时间参数，所以必然会在指定的时间内苏醒，他也不会释放锁，当然，sleep方法的调用非必须在同步方法（同步代码块）内</p>
<p>join是实例方法，表示等待谁，是用于线程顺序的调度方法，可以做到一个线程等待另外一个线程，join有三个版本，指定超时时间或者持续等待直到目标线程执行结束，join也无需在同步方法（同步代码块）内</p>
<p>sleep和join都是可中断方法，被其他线程中断时，都会抛出InterruptedException异常，并且会醒来<br>
join方法底层依赖wait，我们对比下wait与sleep<br>
wait和sleep都会使线程进入阻塞状态，都是可中断方法，被中断后都会抛出异常<br>
wait是Object的方法，sleep是Thread的方法<br>
wait必须在同步中执行，sleep不需要（join底层依赖wait，但是不需要在同步中，因为join方法就是synchronized的）<br>
wait会释放锁，sleep不会释放锁<br>
wait（无超时设置的版本）会持续阻塞，必须等待唤醒，而sleep必然有超时，所以一定会自己醒来<br>
wait 实例方法（Object），在对象上调用，表示在其上等待；sleep静态方法，当前线程</p>
<!-- more -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用的三种设计模式：Singleton、Template、Strategy模式]]></title>
        <id>https://song-2020.Github.io/post/chang-yong-de-san-chong-she-ji-mo-shi-singletontemplatestrategy-mo-shi/</id>
        <link href="https://song-2020.Github.io/post/chang-yong-de-san-chong-she-ji-mo-shi-singletontemplatestrategy-mo-shi/">
        </link>
        <updated>2020-06-15T15:30:13.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-singleton单例模式">一、Singleton单例模式</h1>
<p>单例指的只能存在唯一的一个实例对象(单例)<br>
单例模式的设计思路：先阻止类可以类外部通过new的方式(构造函数)创建实例，并在类的内部创建一个获得该类实例的静态方法，用来创建该类实例（不存在实例时）或者返回实例（存在实例时）从而实现单一实例的控制。<br>
Singleton模式首先先对其构造方法的权限声明为private，阻止类外部通过构造方法创建实例，并采用static来共享对象实例，再提供get方法来获取唯一实例。但是要特别注意的是，在懒汉式例程中get方法内部采用了synchronized锁声明（只允许一个线程进入）。<br>
如果没有声明的情况下，如下：</p>
<p>public static LazyMan getlazyman()<br>
{<br>
if(lazyman== null)<br>
{ lazyman = new LazyMan(); }<br>
return lazyman;<br>
}</p>
<pre><code>在多线程下单例模式 使用是非常危险的（不安全的），有可能出现这种情况，唯一实例并未创建时，多个线程都调用类内部创建类的方法，而且都运行到if(lazyman == null)内部而且在运行lazyman = newLazyMan();之前的地方，这就非常尴尬了，这个时候lazyman=null，if里的条件语句是true，所以可以进入到if内部，也就多个线程都通过了我们原本为了限制实例数量的判断语句，而且下一步都是lazyman= new LazyMan();，这样在堆中就存在多个LazyMan实例了，这就和我们预期遐想的不同了。
</code></pre>
<p>Java中四种线程安全的单例模式实现方式：<br>
第一种：饿汉模式（线程安全）<br>
第二种：懒汉模式 （如果方法没有synchronized，则线程不安全）<br>
第三种：懒汉模式改良版（线程安全，使用了double-check，即check-加锁-check，目的是为了减少同步的开销）<br>
第四种：利用私有的内部工厂类（线程安全，内部类也可以换成内部接口，不过工厂类变量的作用于要改为public了。）</p>
<h1 id="二-template模式模板模式">二、Template模式（模板模式）</h1>
<pre><code>    模板模式，顾名思义，设定了模板，并让接下来代码实现都按照一个模板进行，说到模板，很容易就联想到了抽象类和接口的运用，定义了方法名，没有方法体，然后让子类去实现、继承、扩展他们的方法，那么，抽象类和接口的方法不妨就充当了“模板”的作用，也就是骨架，这就是模板模式。
    在模板模式中，可分为抽象模板(AbstractTemplate)和具体模板(Concrete Template)
    抽象模板也就是骨架，定义一个或多个操作(方法)，以便被子类实现。
    具体模板指的就是对抽象模板的实现，也可以说就是子类。在
    抽象模板中的基础方法又可以分为：抽象方法(AbstractMethod)、具体方法(Concrete Method)、钩子方法(Hook Method)
    抽象方法对应抽象类中的抽象方法，具体方法对应抽象类中具体方法，钩子方法对应抽象类（接口）中的空方法。
    例程：//定义了一个抽象类，名字为SteamRice（煮饭、蒸饭），方法分别为PutRice(下米)、WashRice(洗米)、CookRice(煮米)
</code></pre>
<p>//这个类说明了煮饭的基本过程，是煮饭的骨架，什么饭都是这个步骤。<br>
//而它的子类就对其进行了不同的实现，但是骨架还是不变的。</p>
<h1 id="三-strategy策略模式">三、Strategy策略模式</h1>
<pre><code>    在模板设计模式中，我们是通过抽象类（或者实现接口）制作模板，通过继承抽象类（或者实现接口）来实现模板，是一种重心放在子类上的逻辑。而策略模式其逻辑是反过来的，是一种重心放在父类上的逻辑，主要是通过父类对象对子类改写的方法进行调用。    
    在策略模式中，可以通过策略(Strategy)一词来理解这个模式的逻辑，在逻辑上将策略的作用（目的）和策略的具体实施计划分开，父类被称为抽象策略(Strategy)，也就是相当策略的作用（目的），只提供一个骨架，而其子类被称为具体策略(ConcreteStrategy)，也就是相当策略的具体实施计划，每个子类都是一个计划。当然，既然是策略，那么就有策略的使用者，这个使用者在策略模式中称为Context（上下文、环境），正如上面所说的，在Context中创建一个Strategy的对象引用去调用ConcreteStrategy的具体实现。    
    所以，策略模式是相当于对一系列解决方案（或算法等）包装到一系列的策略类里面去，然后通过父类对象去访问具体实现策略的子类，而提供多种解决方案，因为这些方案都是解决相同的问题，所以这些方案都可以互换，都不会影响使用方案的客户端。</code></pre>
]]></content>
    </entry>
</feed>