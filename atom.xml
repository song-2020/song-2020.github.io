<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://song-2020.Github.io</id>
    <title>彩虹桥</title>
    <updated>2020-07-05T15:48:56.008Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://song-2020.Github.io"/>
    <link rel="self" href="https://song-2020.Github.io/atom.xml"/>
    <subtitle>个人技术博客</subtitle>
    <logo>https://song-2020.Github.io/images/avatar.png</logo>
    <icon>https://song-2020.Github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 彩虹桥</rights>
    <entry>
        <title type="html"><![CDATA[synchronized与volatile]]></title>
        <id>https://song-2020.Github.io/post/synchronized-yu-volatile/</id>
        <link href="https://song-2020.Github.io/post/synchronized-yu-volatile/">
        </link>
        <updated>2020-06-30T15:23:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="synchronized保证三大性原子性有序性可见性">synchronized保证三大性，原子性，有序性，可见性</h1>
<h1 id="volatile保证有序性可见性不能保证原子性">volatile保证有序性，可见性，不能保证原子性</h1>
<h1 id="volatile到底做了什么">volatile到底做了什么:</h1>
<p>禁止了指令重排<br>
保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量值，这个新值对其他线程是立即可见的<br>
不保证原子性（线程不安全）</p>
<h1 id="synchronized关键字和volatile关键字比较">synchronized关键字和volatile关键字比较：</h1>
<p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。<br>
多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞<br>
volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。<br>
volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。<br>
当一个变量定义为 volatile 之后，将具备两种特性：<br>
1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。<br>
2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。<br>
volatile 性能：<br>
volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>
<h1 id="为什么要使用synchronized">为什么要使用synchronized？</h1>
<p>在并发编程中存在线程安全问题，主要原因有：1.存在共享数据 2.多线程共同操作共享数据。<br>
关键字synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile。</p>
<h1 id="相关">相关</h1>
<p>synchronized关键字  : 用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这个段代码。可以对对象加互斥锁。<br>
volatile关键字：用来确保将变量的更新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。然而，在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比 synchronized关键字更轻量级的同步机制。</p>
<h1 id="所谓-volatile的措施就是">所谓 volatile的措施，就是</h1>
<ol>
<li>每次从内存中取值，不从缓存中什么的拿值。这就保证了用 volatile修饰的共享变量，每次的更新对于其他线程都是可见的。</li>
<li>volatile保证了其他线程的立即可见性，就没有保证原子性。<br>
3.由于有些时候对 volatile的操作，不会被保存，说明不会造成阻塞。不可用与多线程环境下的计数器。</li>
</ol>
<p>serialize：Java 对象序列化为二进制文件。<br>
static关键字： static关键字可以修饰变量，方法，静态代码块。<br>
静态变量:<br>
由static修饰的变量称为静态变量<br>
静态变量属于类，而不属于某个对象<br>
静态变量它的副本只有一个(静态变量在类中只加载一)<br>
静态方法：<br>
在静态方法中只能调用静态变量和静态方法<br>
在非静态方法中，可以调用静态方法或者变量。<br>
在静态方法中不能使用this和super关键字。<br>
静态代码块：<br>
作用:用来给静态成员变量初始化</p>
<p>关于原子性，有序性，可见性<br>
可见性：<br>
可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。<br>
可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。<br>
在 Java 中 volatile、synchronized 和 final 实现可见性。<br>
原子性：<br>
原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。<br>
在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。<br>
有序性：<br>
Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Object 类中方法及说明]]></title>
        <id>https://song-2020.Github.io/post/object-lei-zhong-fang-fa-ji-shuo-ming/</id>
        <link href="https://song-2020.Github.io/post/object-lei-zhong-fang-fa-ji-shuo-ming/">
        </link>
        <updated>2020-06-25T15:34:34.000Z</updated>
        <content type="html"><![CDATA[<p>registerNatives()   //私有方法<br>
getClass()    //返回此 Object 的运行类。<br>
hashCode()    //用于获取对象的哈希值。<br>
equals(Object obj)     //用于确认两个对象是否“相同”。<br>
clone()    //创建并返回此对象的一个副本。<br>
toString()   //返回该对象的字符串表示。<br>
notify()    //唤醒在此对象监视器上等待的单个线程。<br>
notifyAll()     //唤醒在此对象监视器上等待的所有线程。<br>
wait(long timeout)    //在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或        者超过指定的时间量前，导致当前线程等待。<br>
wait(long timeout, int nanos)    //在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。<br>
wait()    //用于让当前线程失去操作权限，当前线程进入等待序列<br>
finalize()    //当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[sleep、wait、yield、join]]></title>
        <id>https://song-2020.Github.io/post/sleepwaityieldjoin/</id>
        <link href="https://song-2020.Github.io/post/sleepwaityieldjoin/">
        </link>
        <updated>2020-06-20T15:26:59.000Z</updated>
        <content type="html"><![CDATA[<p>#1.sleep()方法<br>
在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。<br>
sleep()使当前线程进入阻塞状态，在指定时间内不会执行。<br>
#2.wait()方法  会使线程释放锁资源<br>
在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。<br>
当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。<br>
唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。<br>
waite()和notify()必须在synchronized函数或synchronized　block中进行调用。如果在non-synchronized函数或non-synchronized　block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。<br>
#3.yield方法<br>
暂停当前正在执行的线程对象。<br>
yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。<br>
yield()只能使同优先级或更高优先级的线程有执行的机会。<br>
#4.join方法   会使线程释放锁资源<br>
join()等待该线程终止。<br>
等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测</p>
<p>#总结<br>
yield方法：只是简单地对于CPU时间片的“礼让”，除非循环yield，否则一次yield，可能下次该线程仍旧可能会抢占到CPU时间片，可能方法调用和不调用没</p>
<p>#差别<br>
sleep是静态方法，针对当前线程，进入休眠状态，两个版本的sleep方法始终有时间参数，所以必然会在指定的时间内苏醒，他也不会释放锁，当然，sleep方法的调用非必须在同步方法（同步代码块）内</p>
<p>join是实例方法，表示等待谁，是用于线程顺序的调度方法，可以做到一个线程等待另外一个线程，join有三个版本，指定超时时间或者持续等待直到目标线程执行结束，join也无需在同步方法（同步代码块）内</p>
<p>sleep和join都是可中断方法，被其他线程中断时，都会抛出InterruptedException异常，并且会醒来<br>
join方法底层依赖wait，我们对比下wait与sleep<br>
wait和sleep都会使线程进入阻塞状态，都是可中断方法，被中断后都会抛出异常<br>
wait是Object的方法，sleep是Thread的方法<br>
wait必须在同步中执行，sleep不需要（join底层依赖wait，但是不需要在同步中，因为join方法就是synchronized的）<br>
wait会释放锁，sleep不会释放锁<br>
wait（无超时设置的版本）会持续阻塞，必须等待唤醒，而sleep必然有超时，所以一定会自己醒来<br>
wait 实例方法（Object），在对象上调用，表示在其上等待；sleep静态方法，当前线程</p>
<!-- more -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用的三种设计模式：Singleton、Template、Strategy模式]]></title>
        <id>https://song-2020.Github.io/post/chang-yong-de-san-chong-she-ji-mo-shi-singletontemplatestrategy-mo-shi/</id>
        <link href="https://song-2020.Github.io/post/chang-yong-de-san-chong-she-ji-mo-shi-singletontemplatestrategy-mo-shi/">
        </link>
        <updated>2020-06-15T15:30:13.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-singleton单例模式">一、Singleton单例模式</h1>
<p>单例指的只能存在唯一的一个实例对象(单例)<br>
单例模式的设计思路：先阻止类可以类外部通过new的方式(构造函数)创建实例，并在类的内部创建一个获得该类实例的静态方法，用来创建该类实例（不存在实例时）或者返回实例（存在实例时）从而实现单一实例的控制。<br>
Singleton模式首先先对其构造方法的权限声明为private，阻止类外部通过构造方法创建实例，并采用static来共享对象实例，再提供get方法来获取唯一实例。但是要特别注意的是，在懒汉式例程中get方法内部采用了synchronized锁声明（只允许一个线程进入）。<br>
如果没有声明的情况下，如下：</p>
<p>public static LazyMan getlazyman()<br>
{<br>
if(lazyman== null)<br>
{ lazyman = new LazyMan(); }<br>
return lazyman;<br>
}</p>
<pre><code>在多线程下单例模式 使用是非常危险的（不安全的），有可能出现这种情况，唯一实例并未创建时，多个线程都调用类内部创建类的方法，而且都运行到if(lazyman == null)内部而且在运行lazyman = newLazyMan();之前的地方，这就非常尴尬了，这个时候lazyman=null，if里的条件语句是true，所以可以进入到if内部，也就多个线程都通过了我们原本为了限制实例数量的判断语句，而且下一步都是lazyman= new LazyMan();，这样在堆中就存在多个LazyMan实例了，这就和我们预期遐想的不同了。
</code></pre>
<p>Java中四种线程安全的单例模式实现方式：<br>
第一种：饿汉模式（线程安全）<br>
第二种：懒汉模式 （如果方法没有synchronized，则线程不安全）<br>
第三种：懒汉模式改良版（线程安全，使用了double-check，即check-加锁-check，目的是为了减少同步的开销）<br>
第四种：利用私有的内部工厂类（线程安全，内部类也可以换成内部接口，不过工厂类变量的作用于要改为public了。）</p>
<h1 id="二-template模式模板模式">二、Template模式（模板模式）</h1>
<pre><code>    模板模式，顾名思义，设定了模板，并让接下来代码实现都按照一个模板进行，说到模板，很容易就联想到了抽象类和接口的运用，定义了方法名，没有方法体，然后让子类去实现、继承、扩展他们的方法，那么，抽象类和接口的方法不妨就充当了“模板”的作用，也就是骨架，这就是模板模式。
    在模板模式中，可分为抽象模板(AbstractTemplate)和具体模板(Concrete Template)
    抽象模板也就是骨架，定义一个或多个操作(方法)，以便被子类实现。
    具体模板指的就是对抽象模板的实现，也可以说就是子类。在
    抽象模板中的基础方法又可以分为：抽象方法(AbstractMethod)、具体方法(Concrete Method)、钩子方法(Hook Method)
    抽象方法对应抽象类中的抽象方法，具体方法对应抽象类中具体方法，钩子方法对应抽象类（接口）中的空方法。
    例程：//定义了一个抽象类，名字为SteamRice（煮饭、蒸饭），方法分别为PutRice(下米)、WashRice(洗米)、CookRice(煮米)
</code></pre>
<p>//这个类说明了煮饭的基本过程，是煮饭的骨架，什么饭都是这个步骤。<br>
//而它的子类就对其进行了不同的实现，但是骨架还是不变的。</p>
<h1 id="三-strategy策略模式">三、Strategy策略模式</h1>
<pre><code>    在模板设计模式中，我们是通过抽象类（或者实现接口）制作模板，通过继承抽象类（或者实现接口）来实现模板，是一种重心放在子类上的逻辑。而策略模式其逻辑是反过来的，是一种重心放在父类上的逻辑，主要是通过父类对象对子类改写的方法进行调用。    
    在策略模式中，可以通过策略(Strategy)一词来理解这个模式的逻辑，在逻辑上将策略的作用（目的）和策略的具体实施计划分开，父类被称为抽象策略(Strategy)，也就是相当策略的作用（目的），只提供一个骨架，而其子类被称为具体策略(ConcreteStrategy)，也就是相当策略的具体实施计划，每个子类都是一个计划。当然，既然是策略，那么就有策略的使用者，这个使用者在策略模式中称为Context（上下文、环境），正如上面所说的，在Context中创建一个Strategy的对象引用去调用ConcreteStrategy的具体实现。    
    所以，策略模式是相当于对一系列解决方案（或算法等）包装到一系列的策略类里面去，然后通过父类对象去访问具体实现策略的子类，而提供多种解决方案，因为这些方案都是解决相同的问题，所以这些方案都可以互换，都不会影响使用方案的客户端。</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[针对循环优化进行的方法]]></title>
        <id>https://song-2020.Github.io/post/zhen-dui-xun-huan-you-hua-jin-xing-de-fang-fa/</id>
        <link href="https://song-2020.Github.io/post/zhen-dui-xun-huan-you-hua-jin-xing-de-fang-fa/">
        </link>
        <updated>2020-06-01T15:39:33.000Z</updated>
        <content type="html"><![CDATA[<p>#死代码删除，代码外提，强度削弱，删除归纳变量，复写传播</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[String, StringBuffer,StringBuilder的区别]]></title>
        <id>https://song-2020.Github.io/post/string-stringbufferstringbuilder-de-qu-bie/</id>
        <link href="https://song-2020.Github.io/post/string-stringbufferstringbuilder-de-qu-bie/">
        </link>
        <updated>2020-05-28T15:37:39.000Z</updated>
        <content type="html"><![CDATA[<p>java中String、StringBuffer、StringBuilder是编程中经常使用的字符串类，他们之间的区别也是经常在面试中会问到的问题。现在总结一下，看看他们的不同与相同。<br>
#1.可变与不可变<br>
String类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道string对象是不可变的。<br>
private final char value[];<br>
String 为不可变对象,一旦被创建,就不能修改它的值. . 对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去.<br>
StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。<br>
char[] value;<br>
StringBuffer:是一个可变对象,当对他进行修改的时候不会像String那样重新建立对象 , 它只能通过构造函数来建立,  如： StringBuffer sb = new StringBuffer();<br>
不能通过赋值符号对他进行付值. ， 如 sb = &quot;welcome to here!&quot;;//error<br>
对象被建立以后,在内存中就会分配内存空间,并初始保存一个null.向StringBuffer中赋值的时候可以通过它的append方法.      sb.append(&quot;hello&quot;);<br>
#2.是否多线程安全<br>
String中的对象是不可变的，也就可以理解为常量， 显然线程安全 。<br>
AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。<br>
StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是 线程安全的 。看如下源码：</p>
<p>1   public   synchronized  StringBuffer reverse() {<br>
2       super .reverse();<br>
3       return   this ;<br>
4  }<br>
5<br>
6   public   int  indexOf(String str) {<br>
7       return  indexOf(str, 0);         //存在 public synchronized int                 indexOf(String str, int fromIndex) 方法<br>
8  }</p>
<p>StringBuilder并没有对方法进行加同步锁，所以是 非线程安全的 。<br>
#3.StringBuilder与StringBuffer共同点<br>
StringBuilder与StringBuffer有公共父类AbstractStringBuilder( 抽象类 )。<br>
抽象类与接口的其中一个区别是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。<br>
StringBuilder、StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append(...)。只是StringBuffer会在方法上加synchronized关键字，进行同步。<br>
最后，如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。</p>
<p>效率比较String &lt; StringBuffer &lt; StringBuilder，但是在String S1 =“This is only a”+“simple”+“test”时，String效率最高。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java多线程编程]]></title>
        <id>https://song-2020.Github.io/post/java-duo-xian-cheng-bian-cheng/</id>
        <link href="https://song-2020.Github.io/post/java-duo-xian-cheng-bian-cheng/">
        </link>
        <updated>2020-05-15T13:27:03.000Z</updated>
        <content type="html"><![CDATA[<p>#一、定义<br>
Java 给多线程编程提供了内置的支持。<br>
一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。<br>
多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。<br>
这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。<br>
一个线程不能独立的存在，它必须是进程的一部分。<br>
一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。<br>
多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</p>
<p>多进程：<br>
• 当前的操作系统都是多任务OS<br>
• 每个独立执行的任务就是一个进程<br>
• OS将时间划分为多个时间片（时间很短）<br>
• 每个时间片内将CPU分配给某一个任务，时间片结束， CPU将自动回收，再分配给另外任务。从外部看，所有任 务是同时在执行。但是在CPU上，任务是按照串行依次运 行（单核CPU）。如果是多核，多个进程任务可以并行。 但是单个核上，多进程只能串行执行。<br>
• 多进程的优点<br>
–可以同时运行多个任务<br>
–程序因IO堵塞时，可以释放CPU，让CPU为其他程序服务<br>
–当系统有多个CPU时，可以为多个程序同时服务<br>
• 我们的CPU不再提高频率，而是提高核数<br>
• 多核和并行程序才是提高程序性能的唯一办法<br>
• 多进程的缺点<br>
–太笨重，不好管理<br>
–太笨重，不好切换</p>
<p>多线程：<br>
• 一个程序可以包括多个子任务，可串/并行<br>
• 每个子任务可以称为一个线程<br>
• 如果一个子任务阻塞，程序可以将CPU调度另外一个子任 务进行工作。这样CPU还是保留在本程序中，而不是被调 度到别的程序(进程)去。这样，提高本程序所获得CPU时间 和利用率。</p>
<p>多进程和多线程对比<br>
–线程共享数据<br>
–线程通讯更高效<br>
–线程更轻量级，更容易切换<br>
–多个线程更容易管理</p>
<p>#二、一个线程的生命周期<br>
线程是一个动态执行的过程，它也有一个从产生到死亡的过程。<br>
下图显示了一个线程完整的生命周期。<br>
<img src="https://song-2020.Github.io/post-images/1593696513463.png" alt="" loading="lazy"><br>
新建状态:<br>
使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。<br>
就绪状态:<br>
当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。<br>
运行状态:<br>
如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。<br>
阻塞状态:<br>
如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：<br>
等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。<br>
同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。<br>
其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。<br>
死亡状态:<br>
一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>
<p>#三、线程的优先级<br>
每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。<br>
Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。<br>
默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。<br>
具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p>
<p>#四、Java 提供了三种创建线程的方法：<br>
通过实现 Runnable 接口；<br>
通过继承 Thread 类本身；<br>
通过 Callable 和 Future 创建线程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Java中的集合]]></title>
        <id>https://song-2020.Github.io/post/guan-yu-java-zhong-de-ji-he/</id>
        <link href="https://song-2020.Github.io/post/guan-yu-java-zhong-de-ji-he/">
        </link>
        <updated>2020-05-07T12:13:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-概述">一、概述</h1>
<figure data-type="image" tabindex="1"><img src="https://song-2020.Github.io/post-images/1593692066544.png" alt="" loading="lazy"></figure>
<h1 id="二-java集合框架图">二、Java集合框架图</h1>
<p><img src="https://song-2020.Github.io/post-images/1593692291195.png" alt="" loading="lazy"><br>
集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：<br>
接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象<br>
实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。<br>
算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。<br>
除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。</p>
<h1 id="三-集合框架体系">三、集合框架体系</h1>
<figure data-type="image" tabindex="2"><img src="https://song-2020.Github.io/post-images/1593692402821.png" alt="" loading="lazy"></figure>
<h1 id="四-关于线程安全">四、关于线程安全</h1>
<h2 id="1-线程安全thread-safe的集合对象">1、线程安全(Thread-safe)的集合对象：</h2>
<p>Vector 、HashTable 、StringBuffer 、stackenumeration</p>
<h2 id="2-非线程安全的集合对象">2、非线程安全的集合对象：</h2>
<p>ArrayList 、LinkedList、HashMap、HashSet、TreeMap、TreeSet、StringBulider</p>
<h1 id="五-总结">五、总结:</h1>
<h2 id="connection接口">Connection接口:</h2>
<p>—  List 有序,可重复<br>
ArrayList<br>
Arraylist默认数组大小是10，扩容后的大小是扩容前的1.5倍，最大值小于Integer 的最大值减8，如果新创建的集合有带初始值，默认就是传入的大小，也就不会扩容<br>
优点: 底层数据结构是数组，查询快，增删慢。<br>
缺点: 线程不安全，效率高<br>
Vector<br>
优点: 底层数据结构是数组，查询快，增删慢。<br>
缺点: 线程安全，效率低<br>
LinkedList<br>
优点: 底层数据结构是链表，查询慢，增删快。<br>
缺点: 线程不安全，效率高</p>
<p>—Set    无序,不可重复<br>
TreeSet, LinkedHashSet and HashSet 在java中都是实现Set的数据结构<br>
TreeSet, LinkedHashSet and HashSet 的区别：<br>
TreeSet的主要功能用于排序<br>
LinkedHashSet的主要功能用于保证FIFO即有序的集合(先进先出)<br>
HashSet只是通用的存储数据的集合<br>
相同点：Duplicates elements: 因为三者都实现Set interface，所以三者都不包含duplicate elements<br>
Thread safety: 三者都不是线程安全的，如果要使用线程安全可以Collections.synchronizedSet()<br>
不同点：Performance and Speed: HashSet插入数据最快，其次LinkHashSet，最慢的是TreeSet因为内部实现排序<br>
Ordering: HashSet不保证有序，LinkHashSet保证FIFO即按插入顺序排序，TreeSet安装内部实现排序，也可以自定义排序规则<br>
null:HashSet和LinkHashSet允许存在null数据，但是TreeSet中插入null数据时会报NullPointerException</p>
<p>HashSet<br>
底层数据结构是哈希表。(无序,唯一)<br>
如何来保证元素唯一性?<br>
1.依赖两个方法：hashCode()和equals()<br>
LinkedHashSet<br>
底层数据结构是链表和哈希表。(FIFO插入有序,唯一)<br>
1.由链表保证元素有序<br>
2.由哈希表保证元素唯一<br>
TreeSet<br>
底层数据结构是红黑树。(唯一，有序)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java常用基础知识]]></title>
        <id>https://song-2020.Github.io/post/java-chang-yong-ji-chu-zhi-shi/</id>
        <link href="https://song-2020.Github.io/post/java-chang-yong-ji-chu-zhi-shi/">
        </link>
        <updated>2020-04-20T12:06:05.000Z</updated>
        <content type="html"><![CDATA[<p>#java关键字<br>
<img src="https://song-2020.Github.io/post-images/1593691681351.png" alt="" loading="lazy"><br>
#Java三大特性<br>
封装主要是隐藏内部代码；<br>
继承主要是复用现有代码；<br>
多态主要是改写对象行为。<br>
#各种变量的默认值及默认值<br>
<img src="https://song-2020.Github.io/post-images/1593691916709.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring boot技术相关]]></title>
        <id>https://song-2020.Github.io/post/spring-boot-ji-zhu-xiang-guan/</id>
        <link href="https://song-2020.Github.io/post/spring-boot-ji-zhu-xiang-guan/">
        </link>
        <updated>2020-04-02T06:39:07.000Z</updated>
        <content type="html"><![CDATA[<p>#一、什么是 Spring Boot<br>
Spring Boot 是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简<br>
化是指简化了 Spring 众多框架中所需的大量且繁琐的配置文件，所以 Spring Boot 是一个服<br>
务于框架的框架，服务范围是简化配置文件。所以从本质上来说，Spring Boot 其实就是 Spring<br>
框架的另一种表现形式。</p>
<p>#二、 Spring Boot 特征<br>
1、使用 Spring Boot 可以创建独立的 Spring 应用程序<br>
2、在Spring Boot中直接嵌入了Tomcat、<br>
Jetty、Undertow等Web容器，所以在使用SpringBoot<br>
做 Web 开发时不需要部署 WAR 文件<br>
3、过提供自己的启动器(Starter)依赖，简化项目构建配置<br>
4、尽量的自动配置 Spring 和第三方库<br>
5、提供了生产就绪特征，如：度量指标，运行状况检查和外部化配置<br>
6、绝对没有代码生成，也不需要 XML 配置文件</p>
<p>#三、Spring Boot 的核心注解<br>
5.1@SpringBootApplication<br>
是 SpringBoot 的启动类。<br>
此注解等同于@Configuration+@EnableAutoConfiguration+@ComponentScan 的组合。<br>
5.2@SpringBootConfiguration<br>
@SpringBootConfiguration 注解是@Configuration 注解的派生注解，跟@Configuration<br>
注解的功能一致，标注这个类是一个配置类，只不过@SpringBootConfiguration 是 springboot<br>
的注解，而@Configuration 是 spring 的注解<br>
5.3@Configuration<br>
通过对 bean 对象的操作替代 spring 中 xml 文件<br>
5.4@EnableAutoConfiguration<br>
Spring Boot 自动配置（auto-configuration）：尝试根据你添加的 jar 依赖自动配置你的<br>
Spring 应用。是@AutoConfigurationPackage 和@Import(AutoConfigurationImportSelector.class)<br>
注解的组合。<br>
5.5@AutoConfigurationPackage<br>
@AutoConfigurationPackage 注解，自动注入主类下所在包下所有的加了注解的类<br>
（@Controller，@Service 等），以及配置类（@Configuration）<br>
5.6@Import({AutoConfigurationImportSelector.class})<br>
直接导入普通的类<br>
导入实现了 ImportSelector 接口的类<br>
导入实现了 ImportBeanDefinitionRegistrar 接口的类<br>
5.7@ComponentScan<br>
组件扫描，可自动发现和装配一些 Bean。<br>
5.8@ConfigurationPropertiesScan<br>
@ConfigurationPropertiesScan 扫描配置属性。@EnableConfigurationProperties 注解的作<br>
用是使用 @ConfigurationProperties 注解的类生效。</p>
<p>#四、Spring Boot 整合 Thymeleaf<br>
3.1Thymeleaf 介绍<br>
Thymeleaf 的主要目标是将优雅的自然模板带到开发工作流程中，并将 HTML 在浏览器<br>
中正确显示，并且可以作为静态原型，让开发团队能更容易地协作。Thymeleaf 能够处理<br>
HTML，XML，JavaScript，CSS 甚至纯文本。<br>
长期以来,jsp 在视图领域有非常重要的地位,随着时间的变迁,出现了一位新的挑战<br>
者:Thymeleaf,Thymeleaf 是原生的,不依赖于标签库.它能够在接受原始 HTML 的地方进行编<br>
辑和渲染.因为它没有与Servelet规范耦合,因此Thymeleaf模板能进入jsp所无法涉足的领域。</p>
<p>Spring Boot 整合mybatis框架<br>
MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
<p>generator插件<br>
可根据配置文件自动为mybatis项目生成mapper和pojo文件</p>
<p>spring boot热部署<br>
使用devtools或者jrebel工具</p>
<p>Spring Boot 度量指标监控与健康检查<br>
使用 Actuator 检查与监控<br>
使用可视化监控应用 Spring Boot Admin</p>
<p>#五、 关于Spring<br>
Spring是一系列轻量级Java EE框架的集合<br>
Spring中包含一个“依赖注入”模式的实现<br>
使用Spring可以实现声明式事务</p>
<p>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。<br>
轻量——从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。<br>
控制反转——Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。<br>
面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。<br>
容器——Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。<br>
框架——Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</p>
<p>spring没有提供AOP方式的日志系统。<br>
AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态***实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。<br>
Spring通过对AOP的支持，借助log4j等Apache开源组件实现了日志系统。</p>
<p>spring由哪些框架组成？<br>
spring context ,spring aop ,springMVC ,spring ORm ,spring web ,spring dao,core context</p>
]]></content>
    </entry>
</feed>