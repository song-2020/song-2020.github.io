<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://song-2020.Github.io</id>
    <title>脚踏实地，仰望星空</title>
    <updated>2020-07-06T01:11:37.741Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://song-2020.Github.io"/>
    <link rel="self" href="https://song-2020.Github.io/atom.xml"/>
    <subtitle>个人技术博客</subtitle>
    <logo>https://song-2020.Github.io/images/avatar.png</logo>
    <icon>https://song-2020.Github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 脚踏实地，仰望星空</rights>
    <entry>
        <title type="html"><![CDATA[Java练习题]]></title>
        <id>https://song-2020.Github.io/post/java-lian-xi-ti/</id>
        <link href="https://song-2020.Github.io/post/java-lian-xi-ti/">
        </link>
        <updated>2020-07-03T01:10:51.000Z</updated>
        <content type="html"><![CDATA[<p>第一部分  选择题（单选）<br>
1.javac 是 Java 的 (  )。 B<br>
A. 解释器 B. 编译器 C. 小程序浏览器 D. 调试器<br>
2. appletviewer 是 Java 的 (  )。 C<br>
A. 解释器 B. 编译器 C. 小程序浏览器 D. 调试器<br>
3.编译一个定义了三个类和三个方法的 Java 源码文件，总共会产生几个字节码文件，其扩展名是什么？(  ) C<br>
A. 5 个字节码文件，其扩展名是”.java”。B. 2 个字节码文件，其扩展名是”.java”。<br>
C. 3 个字节码文件，其扩展名是”.class”。D. 2 个字节码文件，其扩展名是”.class”。<br>
4.Java 源码文件的名称与主类的名称(  )。B<br>
A. 必须相同但不区分大小写 B. 必须相同且区分大小写 C. 必须不同 D. 任意<br>
5.下面哪些选项不能用作变量名的首字符？（  ）C<br>
A. 字母 B. 下划线(<em>)C. 数字 D. 美元符($)<br>
6.下面哪个不是 Java 的原始数据类型？（  ） C<br>
A. shortB. boolean  C. IntD. float<br>
7.下面哪条语句不会出现编译警告或错误？（  ） A<br>
A. float f=1.3F;B. char c=”a”;C. float f=1.3;D. boolean d=null;<br>
8.以下声明常量不正确的是（  ） 。 B<br>
A. final int PI=3;B. final PI=3;C. static final int PI=3;D. public static final int PI=3;<br>
9.Java 定义了 4 个整型数据类型：字节型（byte） 、短整型（short） 、整型（int） 、长整型（long） ，其中 byte 占用内存为 A<br>
A. 8 bitB. 16 bitC. 32 bitD. 64 bit<br>
10.5%2.1 的值是(  )。 C<br>
A. 1 B. 0 C. 0.8 D. 不能通过编译<br>
11. -11&amp;3 的值是(  )。 A<br>
A. 1 B. 3 C. 9 D. -11<br>
12..8&lt;&lt;2 值是(  )。 D<br>
A. 2 B. 4 C. 8  D. 32<br>
13.若有 int a=1,b=2,c=3,d=4;，则表达式 a&gt;b ? a:c&gt;d ? c:d 的值是(  )。D<br>
A. 1 B. 2 C. 3 D. 4<br>
14.以下为合法类型转换的为（  ） 。 D<br>
A. (int)”A”B. (char)”A”C. (boolear)(2-2)D. (char)(651/12)<br>
15.下面哪条语句是正确的？（  ）C<br>
A. int a={1,2,3,4,5};B. int b=(1,2,3,4,5);C. int c[]={1,2,3,4,5};D. int []d={1 2 3 4 5};<br>
16.对于数组 int a[];下面哪条语句可以输出数组 a 的元素的个数？ D<br>
A. System.out.println(a.size);B. System.out.println(a.size( ));<br>
C. System.out.println(a.length());D. System.out.println(a.length);<br>
17. 可以用作 switch 表达式的基本数据类型分别是（  ） 。B<br>
A. Boolean  B. byte  C. float D. double<br>
18.下面的 while 语句退出时， i 的值是（  ） 。C<br>
byte b=1;int i=0; while(b++&gt;0) i=i+1;<br>
A. 126 B. 0 C. 127 D. 出现死循环，i 的值为无穷大。<br>
19.设 J_Hello.java 文件内容如下：<br>
class J</em> Hello { static void main(String args[]){   System.out.println(“Hello!”); }}<br>
下面正确的说法是： （  ） B<br>
A. J_Hello.java 无法通过编译。<br>
B. J_Hello.java 可以通过编译，但运行时出现”Main method not public”提示信息。<br>
C. J_Hello.java 可以通过编译，但无法运行，且无任何提示信息。<br>
D. J_Hello.java 可以通过编译，可以正常运行，输出”Hello!。<br>
20.下面哪个类声明是正确的。 （  ） D<br>
A. abstract final class car{} B. abstract private car(){}<br>
C. protected private car{} D. public abstract class car{}<br>
21.下列（  ）的说法是错误的。 C<br>
A. Java 语言只允许单一继承 B. Java 语言允许多个接口<br>
C. Java 语言不允许一个类派生多个子类 D. Java 语言的单一继承使得代码更加可靠<br>
22.下述（  ）说法是正确的。 A<br>
A. 实例变量是类的成员变量 B. 实例变量是用 static 关键字声明的<br>
C. 方法变量在方法执行时创建 D. 方法变量在使用之前不用初始化<br>
23.使用继承的优点是（  ） A<br>
A. 基类的大部分功能可以通过继承关系自动进入派生类 B. 继承将基类的实现细节暴露给派生类<br>
C. 一旦基类实现出现问题，就会影响到派生类 D. 可在运行期决定是否选择继承代码，有足够的灵活性<br>
24.下列关于修饰符混用的说法，错误的是（  ） 。 D<br>
A. abstract 不能与 final 并列修饰同一个类 B. abstract 类中不能有 private 的成员<br>
C. abstract 方法必须在 abstract 类中 D. static 方法中能处理非 static 的属性<br>
25.对于下列代码：<br>
public class Parent<br>
{ public int addValue(int a,int b)  {int s;s=a+b; return s;}}class Child extends Parent {…}<br>
Child 类中欲把 Parent 类中的 addValue 方法覆盖，下述什么方法可以加入类 Child 中？（  ） C<br>
A. private int addValue(int a,int b){…}    B. public float addValue(int a,int b){…}<br>
C. public int addValue(int a,int b){…}     D. public int addValue(int a,int b)throws MyException{…}<br>
26.声明成员变量为临时变量（又称为过渡变量）所用的保留字是（  ） 。 C<br>
A. final B. Abstract C. Transient D. temp<br>
27.声明公共变量所用的保留字是（  ） 。 A<br>
A. public B. private C. protected D. static<br>
28.声明受保护变量所用的保留字是（  ） 。C<br>
A. public B. private C. protected D. static<br>
29.设有下面的程序段：</p>
<ol>
<li>class StaticStuff</li>
<li>{</li>
<li>static int x=10;</li>
<li>static {x+=5;}</li>
<li>public static void main(String args[])</li>
<li>{</li>
<li>System.out.println(“x=”+x);</li>
<li>}</li>
<li>static {x/=3;}</li>
<li>}<br>
哪个说明是正确的是（  ） 。 C<br>
A. 4 行和 9 行不能通过编译，因为缺少方法名和返回类型 B. 9 行不能通过编译，因为只能有一个静态初始化器<br>
C. 编译通过，执行结果为：x=5  D. 编译通过，执行结果为：x=3<br>
30.对于下述类定义哪个说法正确？（  ） D<br>
class MyString extends String{…}<br>
A. 可以成功编译        B. 无法编译，因为没有 main 方法<br>
C. 无法编译，因为 String 是抽象类      D. 无法编译，因为 String 是 final 类<br>
31.不能在 Java 派生类中被覆盖的方法是（  ） 。 C<br>
A. 构造函数 B. 动态方法 C. final 方法 D. 抽象方法<br>
32.关于方法覆盖，下面哪个说法是错误的？（  ） A<br>
A. 方法覆盖可以发生在任意类之间。B. 覆盖方法与被覆盖的方法返回值类型相同。<br>
C. 如果被覆盖的方法是用 public 修饰的，覆盖方法也必须用 public 修饰。<br>
D. 覆盖方法不能抛出比被覆盖的方法更多的异常。<br>
33.下面哪个方法声明是正确的？（  ） C<br>
A. abstract final String abc(){ }B. public abstract abc(){ }<br>
C. private static void abc(){ }D. public abstract static void abc(){ }<br>
34.编译以下代码，将出现什么情况？（  ） B<br>
abstract class Shape{  abstract void draw();}class Square extends Shape{ }<br>
A. Square 类和 Shape 类都可以成功编译 B. Square 类无法编译，但 Shape 可以编译<br>
C. Shape 类无法编译，但 Square 但可以编译 D. Square 类和 Shape 类都无法编译<br>
35.关于 Java 的垃圾回收机制，下面哪些结论是正确的？（  ） B<br>
A. 程序可以任意指定释放内存的时间 B. 正确的程序写法是不能依赖垃圾回收的时间或者顺序<br>
C. 程序不能标识某个局部变量的引用不再被使用 D. 程序可以显示地立即释放对象占有的内存<br>
36.要求设计一个类，它拥有一个特殊的成员域，该成员域必须能够被这个类的子类访问到，但是不能被不在同一个包内的其它类访问到，下面哪些设计可以满足上述要求？（  ） C<br>
A. 该成员域的封装属性设置为 public       B. 该成员域的封装属性设置为 private<br>
C. 该成员域的封装属性设置为 protected      D. 该成员域不需要特殊的封装属性<br>
37.接口的实现所用的关键字是（  ） 。 B<br>
A. interface B. implements      C. extends     D. throws<br>
38.在编写异常处理的 Java 程序中，每个 catch 语句块应该与什么语句块对应？（  ）C<br>
A. if-else    B. Switch      C. Try    D. throw<br>
39.在编写 Java Application 程序时，若需要使用到标准输入/输出语句，必须在程序的开头写上什么语句？（  ） C<br>
A. import java.awt.<em>;    B. import java.applet.Applet;<br>
C. import java.io.</em>;     D. import java.awt.Graphics;<br>
40.下面哪个类最适合处理大数据量的文本文件？（  ） C<br>
A. java.io.FileInputStream  B. java.io.FileReaderC. java.io. BufferedReader    D. java.io.RandomAccessFile<br>
41.以下什么类不属于字符流类？（  ） C<br>
A. Reader  B. FileReader   C. BufferedInputStream  D. StringReader<br>
42.在设计 Java 的数据流操作的程序中，必须加入什么语句？（  ） C<br>
A. import java.awt.<em>;   B. import java.applet.</em>;   C. import java.io.<em>;  D. import java.awt.event.</em>;<br>
43.以下哪个可能包含菜单条？（  ） B<br>
A. Panel B. Frame C. Applet D. Dialog<br>
44.以下代码完成画线功能，指出所画线的颜色。 （  ） D<br>
g.setColor(Color.red.green.yellow.cyan);g.drawLine(0,0,100,100);<br>
A. red  B. green  C. yello  D. cyan<br>
45.Thread 类的什么方法实现线程的暂时停止操作？（  ） D<br>
A. destroy() B. stop() C. sleep() D. suspend()<br>
46.处理线程间通信等待和通知的方法是（  ） 。 A<br>
A. wait()和 notify() B. start()和 stop() C. run()和 stop() D. wait()和 suspend()<br>
47.在 Java 中，开发图形用户界面的程序需要使用系统提供的类库，这个类库是（  ） 。 B<br>
A. java.io B. java.awt C. java.appletD. java.awt.event<br>
48.applet 所在的页面被浏览和加载后，applet 就诞生了。当浏览器切换到别的页面时，它的什么方法被调用？（  ） C<br>
A. init B. Start C. Stop  D. destroy<br>
49.标签组件由什么类生成（  ） 。 A<br>
A. Label    B. Button     C. Choice     D. Checkbox<br>
50．画矩形，使用什么方法？（  ） B<br>
A. drawLing(x1,y1,x2,y2) B. drawRect(x1,y1,w,h) C. drawOval(x1,y1,w,h) D. drawString(s,x1,y1)<br>
51.Java 是什么公司推出的一种面向对象的现代程序设计语言？ (  ) A<br>
A. SUN 公司 B. Borland 公司 C. IBM 公司 D. Microsoft 公司<br>
55.设 x=1，y=2，z=3，则表达式 y+=z++/x--的值是(  )。 D<br>
A. 3  B. 3.5  C. 4  D. 5<br>
56.11&amp;-3 的值是(  )。 C<br>
A. 1 B. 3 C. 9 D. -11<br>
57.下面哪条语句是正确的？（  ） C<br>
A. int []a1=new double[3[;  B. int a2[][]=new double[];  C. int a3[][]={{1},{1,2},{1,2,3}};<br>
D. int a4[3]={1.0,2.0,3.0};</li>
<li>为 AB 类的一个无形式参数的方法 method 书写方法头，使得使用类名 AB 作为前缀就可以调用它，该方法头的形式为（  ） 。 A<br>
A. static void method() B. public void method() C. final void method() D. abstract void method()<br>
65.在 Java Applet 程序用户自定义的 Applet 子类中，一般需要重载父类的什么方法来完成主类实例的初始化工作。 C<br>
A. start()B. stop() C. init() D. paint()<br>
第二部分  填空题<br>
1.Sun 公司提供的 Java 开发工具包，用于台式机的开发工具包是   JDK       。<br>
2.Java 程序可分为两种基本类型，它们是  基本数据类型    和  复合数据类型   。<br>
3.Java 虚拟机运行 Java 程序的基本步骤是： 首先从后缀为 .java   的文件加载代码到内存中， 接着在内存中  检查       代码的合法性及安全性，然后  顺序      执行安全和合法的代码。<br>
4.Java 标识符是由 字母数字下划线美元符    组成的字符序列。<br>
5.Java 字符（char）采用的是 ISO 规定的  unicode      字符集。<br>
6.int 类型数据在内存中占  4   个 2 进制位。</li>
<li>在 Java 语言中，字符串直接量是用  “”        括起来的字符序列。<br>
8.字符串不是字符数组，而是类  实例化       的实例对象。<br>
9.在类中声明的变量叫   属性        ,可在  类      中使用。<br>
10.在方法和方法块中声明的变量叫局部变量 ,其使用范围是  方法中   。<br>
11.byte 或 short 或 int 类型数据与 long 类型数据混合运算时，其结果是 long     类型.<br>
12.设 x=2，则表达式(x++)/3 的值是  0    。<br>
13.设 x=5，y=10, 则表达式 x&gt;y&amp;&amp;x++==y--的值是 false     。<br>
14.设有运算符!=、*、&amp;&amp;、&gt;=、？：按优先级从高到低的排列顺序是 * != &gt;= &amp;&amp; ? :  。<br>
15.表达式(3&lt;5)^(6&lt;4)的值是 true     。<br>
16.表达式(byte)(1200) 的值是 -80     。<br>
17.数组对象的长度在数组对象创建之后，就不能      改变。<br>
18.已知数组 a 的定义是“int a[]={1,2,3,4,5};”则这时 a[2]的值是 3    。<br>
19.如有声明 float a[][]=new float[3][4];则系统为该数组分配 12 个字节的空间。<br>
20.对于数组 int [][]t={{1,2,3,4},{5,6,7,8}};，t.length 等于2   ，t[0].length 等于   4  。<br>
21.switch 语句中的 case 后面的常量可以是 byte   short  类型、和 int      类型,<br>
22.若有 byte b=1;int i=0; while(++b&gt;0) i=i+1;，则 while 退出时 i 的值为 126      。<br>
23.面向对象的计算机语言一般应有 3 个基本特征，分别是 封装 、继承   和多态  。<br>
24.如果一个 Java Applet 源程序文件只定义有一个类，其类名为 MyApplet，则类 MyApplet 必须是 Applet       类的子类<br>
25.一个复杂的系统往往包含多个对象，这些对象间可能存在的关系有三种，它们是 继承       、   聚合     和  关联       。</li>
<li>抽象   方法是一种仅有方法头，没有具体方法体个操作实现的方法，该方法必须在抽象类中定义。</li>
<li>final       方法是不能被当前类的子类重新定义的。<br>
28.Java 语言通过 垃圾回收 机制简化了程序的内存管理。<br>
29.在 Java 中有两种多态，一种是使用方法的 重载 实现多态，另一种是使用方法的         重写 实现多态。<br>
30.由 protected 修饰的变量称为  受保护变量   ，可被 包内和包外子类中    访问。<br>
31.抽象方法是指 只有声明没有实现   的方法，抽象方法只能出现在  抽象类       中。<br>
32．.在 Java 类的层次结构中，最顶端的类是 Object   ，它在 java.lang包   中定义，是所有类的始祖。<br>
33.不能覆盖父类中的  final  方法和  private       方法。<br>
34.创建子类对象实例时，系统可以自动调用父类的 无参  构造方法，初始化属性                的数据。</li>
<li>对于父类中的构造方法，系统不能自动调用它们，只能通过在子类构造方法中使用关键字  super      调用， 其调用语句位置必须是 方法中可执行语句的第一句 。<br>
36.创建一个名为 MyPackage 的包的语句是  package MyPackage;   ，该语句应该放在程序的位置为：第一句         。<br>
37.Java 提供的异常处理机制包括两个过程 捕获      和  处理     。<br>
38.在 Java 程序中，通过接口的定义可以实现 多      重继承关系。<br>
39.顺序执行以下两条语句的输出结果是：3 。String s=”沈阳市”;System.out.println(s.length());<br>
40.字符串分为两大类，一类是字符串常量，使用 String  类的对象表示；另一类是字符串变量，使用 StringBuffer   类的对象表示。<br>
41.创建一个标识有“关闭”按钮的语句是 JButton button=new JButton(“关闭”)。<br>
42.Java 的组件主要在 JFrame         和 JPanel         中。<br>
43.线程创建后，可以在任何时刻调用  setPriority          方法改变线程的优先级。<br>
44.调用  stop      方法可以停止线程的运行。<br>
45.applet 所在的页面被浏览和加载后，applet 就诞生了。当浏览器切换到别的页面时，它的  stop      方法被调用。<br>
46.标签组件由 JLabel      类生成。<br>
47.画矩形的方法是  drawRect  。<br>
48.关键字 synchronized 的作用是  同步   。<br>
49.wait()方法与 notify()或 notifyAll()方法只能用在   同步        方法中。<br>
50.当线程对象被调度执行时自动调用 run 方法。<br>
58.多态是指接口的多种不同的实现方式。<br>
第三部分  回答问题<br>
1.上机编译编写的源程序，使用什么命令进行编译？源程序文件的扩展名是什么？Java 编译器产生的文件扩展名是什么？<br>
2.上机解释执行编译好的程序，使用什么命令进行解释？Java 解释器解释的文件的扩展名是什么？<br>
3.简述 Java 语言的主要特点。<br>
4．Java 应用程序和 Java 小应用程序有何区别？<br>
5.Java 能跨操作系统平台运行的原理是什么？<br>
6.简述 Java 程序的框架结构。<br>
7.float 和 double 型数据在赋值时有哪些注意事项？<br>
8.float 和 double 型数据在赋值时有哪些注意事项?<br>
9.Java 为什么把字符串定义为类？为什么定义了两个字符串类？<br>
10.静态变量有何特点？如何存取静态变量？</li>
<li>静态方法有何特点？静态方法存取成员变量时有何要求？<br>
12.什么是抽象类、抽象方法？它们有什么特点？<br>
13.类与对象有何关系？如何创建对象？<br>
14.什么是类变量、成员变量、实例变量、局部变量？<br>
15.什么是类的多态性？何为隐藏、覆盖、重载？<br>
16.this 和 super 有什么作用？<br>
17.什么是构造方法？构造方法有何特点和作用？<br>
18.设 Object 类派生出 G 类，G 类派生出 F 类，F 类派生出 Me 类。<br>
问：①构造器的调用顺序是什么。？<br>
②如果父类的构造器重载了，可通过什么方法调用父类中某个指定的构造器？<br>
③如果子类自己的构造器重载了，可通过什么方法在一个构造器中调用另一个构造器？<br>
19.什么是标准输入输出方法？什么是标准输入输出设备？标准输入方法read在使用中应注意什么？它输入的数据是什<br>
么类型？<br>
20．包有什么作用？Java 系统提供了哪些常用包？如何使用包？<br>
21．接口有什么作用？接口有哪些性质？<br>
22．什么是异常？为什么要进行异常处理？如何创建一个自定义异常？如何抛出自定义异常？<br>
23． 试述 Java Applet 的工作原理，其生命周期是如何划分的？<br>
24．如何从 HTML 文件中向 Applet 传递参数？这些参数是如何被接收和处理的？</li>
</ol>
<p>7<br>
25.什么是 Java 数据流？<br>
26.简述 Java 虚拟机的执行过程。<br>
27.Java 为什么把字符串定义为类？为什么定义了两个字符串类？<br>
28.什么是构造方法？构造方法有何特点和作用？<br>
29．试述 Java Applet 的工作原理，其生命周期是如何划分的？</p>
<p>第四部分  写出下面程序的运行结果或完成的功能（以下各程序请自己上机通过，得出结果。 ）<br>
1.public class sum{<br>
public static void main(String args[]){<br>
double sum=0.0;<br>
for(int i=1;i&lt;=100;i++)<br>
sum+=1.0/(double)I;<br>
System.out.println(“sum=”+sum);<br>
}<br>
}<br>
2.public class J_Test7{<br>
public static void main(String args[]){<br>
int i=1,x=2;<br>
switch(x){<br>
case 1:i++;<br>
case 2:i--;<br>
case 3:++i;break;<br>
case 4:--i;}  System.out.println(i); }}<br>
3.class Q1{<br>
public static void main(String args[]){<br>
double d=5.55;<br>
Dec dec=new Dec();<br>
dec.decrement(d);<br>
System.out.print(d);<br>
}<br>
}<br>
class Dec{<br>
public void decrement(double decMe){<br>
decMe= decMe-1;<br>
}<br>
}<br>
4.使用命令 java abc Good Moning 运行下面程序，问输出<br>
什么？<br>
public class abc{<br>
public static void main(String args[]){<br>
Charger c=new Charger();<br>
c.method(args);<br>
System.out.print(args[0]+” “+args[1]);<br>
}<br>
}<br>
class Charger{<br>
void method(String[] s){<br>
String temp=s[0];<br>
s[0]=s[1];<br>
s[1]=temp;<br>
}<br>
}<br>
5.设有如下程序：<br>
public class J_Test9{</p>
<p>public static void main(String args[]){</p>
<p>int sum=0;</p>
<p>a:  for(int i=1;i&lt;12;i++) {</p>
<pre><code>for(int j=1;j&lt;4;j++) { 

 sum+=j; 

 if(i+j&gt;5) break a; } 
</code></pre>
<p>}</p>
<p>System.out.println(&quot;sum=&quot;+sum);<br>
}</p>
<p>}<br>
6．class J_Base<br>
{<br>
public void mb_method()<br>
{<br>
System.out.println(&quot;Base&quot;);<br>
}<br>
}<br>
class J_Test15 extends J_Base<br>
{<br>
public void mb_method()<br>
{<br>
System.out.println(&quot;Test&quot;);<br>
}<br>
public static void main(String args[])<br>
{<br>
Object a=new J_Test15();<br>
((J_Base)a).mb_method();<br>
}<br>
}<br>
7．public class J_Test16<br>
{<br>
static int m_data=0;<br>
public int mb_method()<br>
{<br>
m_data++;</p>
<p>8<br>
return m_data;<br>
}<br>
public static void main(String args[])<br>
{<br>
J_Test16 a=new J_Test16();<br>
J_Test16 b=new J_Test16();<br>
J_Test16 c=new J_Test16();<br>
a.mb_method();<br>
b.mb_method();<br>
c.mb_method();<br>
int i=a.mb_method();<br>
System.out.println(i);<br>
}<br>
}<br>
8． public class J_Test17<br>
{<br>
int m_i=2;<br>
String m_s=null;<br>
J_Test17()<br>
{<br>
m_i=2;<br>
m_s=&quot;record&quot;;<br>
}<br>
public static void main(String args[])<br>
{<br>
J_Test17 app=new J_Test17();<br>
System.out.println(app.m_i+app.m_s);<br>
}<br>
}</p>
<p>9.public class abc{<br>
public static void main(String args[]){<br>
SubClass sb=new SubClass();<br>
System.out.println(sb.max());<br>
}<br>
}<br>
class SuperClass{<br>
int a=10,b=30;<br>
}<br>
class SubClass extends SuperClass{<br>
int max() {return((a&gt;b)? a:b);<br>
}<br>
}<br>
10class J_Base{<br>
public int m_data=6;<br>
public void mb_print()<br>
{<br>
System.out.print(m_data);<br>
}<br>
}<br>
class J_SubClass extends J_Base{<br>
public int m_data=3;<br>
public void mb_print()<br>
{<br>
System.out.print(m_data);<br>
}<br>
}<br>
class J_Test{<br>
public static void main(String args[]){<br>
J_Base app=new J_SubClass();<br>
app.mb_print();<br>
System.out.println(app.m_data);<br>
}<br>
}<br>
11.class Parent{<br>
void printMe()<br>
{System.out.println(“parent”);}<br>
}<br>
class Child extends Parent{<br>
void printMe()<br>
{System.out.println(“child”);}<br>
void printAll()<br>
{<br>
super.printMe();<br>
this. printMe();<br>
printMe();<br>
}<br>
}<br>
public class Test_this{<br>
public static void main(String args[]){<br>
Child myC=new Child();<br>
myC. printAll();<br>
}}<br>
12.import java.awt.*;<br>
public class St{<br>
public static void main(String args[]){<br>
String forwards=new String(“I love Java”);<br>
String backwards=” ”;<br>
System.out.println(forwards);<br>
int lastCharPos=( forwards.length()-1);<br>
int i;<br>
for(i= lastCharPos;i&gt;=0;i--)<br>
backwards+= forwards.charAt(i);<br>
System.out.println(backwards);<br>
}<br>
}</p>
<p>9<br>
13.class J_Base{<br>
public int m_data=1;<br>
public String mb_method()<br>
{return “2”;}<br>
}<br>
class J_Test extends J_Base{<br>
public int m_data=3;<br>
public String mb_method() {return “4”;}<br>
public static void main(String args[]){<br>
J_Base<br>
app=new<br>
J_Test();<br>
System.out.println(app.m_data+app.mb_method());<br>
}<br>
}<br>
14．public class H1{<br>
static int c;<br>
int a,b;<br>
public static void main(String[] s){<br>
int a=1,b=2,c=3;<br>
H1 h1=new H1();<br>
H1 h2=new H1();<br>
h1.a=4;<br>
h2.a=5;<br>
System.out.println(a);<br>
System.out.println(b);<br>
System.out.println(h1.a);<br>
System.out.println(h2.a);<br>
System.out.println(c);<br>
System.out.println(H1.c);<br>
}<br>
}<br>
15.abstract class V1{<br>
abstract int abc();<br>
}<br>
class E1 extends V1{<br>
int abc(){<br>
return 1;<br>
}<br>
}<br>
class H1{<br>
public static void main(String[] s){<br>
E1 e1=new E1();<br>
System.out.println(e1.abc());<br>
}<br>
}<br>
16.class H2{<br>
void ex(int[] y){<br>
for(int i=0;i&lt;y.length;i++)<br>
y[i]=y[i]+1;<br>
}<br>
}<br>
class H1{<br>
public static void main(String[] s){<br>
int[] x={1,2,3,4};<br>
for(int i=0;i&lt;x.length;i++)<br>
System.out.print(x[i]+&quot; &quot;);<br>
System.out.println();<br>
H2 h=new H2();<br>
h.ex(x);<br>
for(int i=0;i&lt;x.length;i++)<br>
System.out.print(x[i]+&quot; &quot;);<br>
}<br>
}<br>
17.class V1{<br>
int a=1;<br>
}<br>
class E1 extends V1{<br>
int b=2,c;<br>
void m1(){<br>
c=a+b;<br>
System.out.println(c);<br>
}<br>
}<br>
class H1{<br>
public static void main(String[] s){<br>
E1 e1=new E1();<br>
e1.m1();<br>
}<br>
}<br>
18.class V1{<br>
int a=1;<br>
}<br>
class E1 extends V1{<br>
int a=30,b=20,c;<br>
void m1(){<br>
c=a+b;<br>
System.out.println(c);<br>
} }<br>
class H1{<br>
public static void main(String[] s){<br>
E1 e1=new E1();<br>
e1.m1();<br>
}}<br>
19.class V1{<br>
int a=1;<br>
void m1(){<br>
System.out.println(&quot;V1.m1&quot;);</p>
<p>10<br>
} }<br>
class E1 extends V1{<br>
int a=3,b=2,c;<br>
void m2(){<br>
System.out.println(&quot;E1.m2&quot;);<br>
} }<br>
class H1{<br>
public static void main(String[] s){<br>
E1 e1=new E1();<br>
e1.m1();<br>
e1.m2();<br>
}}<br>
20.class V1{<br>
V1(){<br>
System.out.println(&quot;V1&quot;);<br>
}<br>
}<br>
class V2 extends V1{<br>
V2(){<br>
System.out.println(&quot;V2&quot;);<br>
}<br>
}<br>
class V3 extends V2{<br>
V3(){<br>
System.out.println(&quot;V3&quot;);<br>
}<br>
}<br>
class H1{<br>
public static void main(String[] s){<br>
V3 e1=new V3(); }}<br>
21.public class abc{<br>
public static void main(String args[]){<br>
int i.Max,Min;<br>
int a[]={12,67,8,98,23,56,124,55,99,100};<br>
Max=a[0];Min=a[0];<br>
for(i=1; i&lt;a.length;i++){<br>
if(a[i]&lt;Min) Min=a[i];<br>
if(a[i]&gt;Max) Max=a[i];<br>
}<br>
System.out.print(Max+” “+Min);<br>
}<br>
}<br>
22.设有如下程序：<br>
public class J_Test9{</p>
<p>public static void main(String args[]){</p>
<p>int sum=0;</p>
<p>for(int i=1;i&lt;10;i++) {</p>
<p>a:   for(int j=1;j&lt;3;j++) {</p>
<pre><code>  sum+=j; 

  if(i+j&gt;6) break a; } 
</code></pre>
<p>}</p>
<p>System.out.println(&quot;sum=&quot;+sum); }</p>
<p>}<br>
23.public class J_Test16<br>
{<br>
static int m_data=0;<br>
public int mb_method()<br>
{<br>
m_data++;<br>
return m_data;<br>
}<br>
public static void main(String args[])<br>
{<br>
J_Test16 a=new J_Test16();<br>
J_Test16 b=new J_Test16();<br>
J_Test16 c=new J_Test16();<br>
a.mb_method();<br>
b.mb_method();<br>
c.mb_method();<br>
int i=a.mb_method();<br>
System.out.println(i);<br>
}<br>
}<br>
24.class V1{<br>
V1(){<br>
System.out.println(&quot;V1&quot;);<br>
}<br>
}<br>
class V2 extends V1{<br>
V2(){<br>
System.out.println(&quot;V2&quot;);<br>
}<br>
}<br>
class V3 extends V2{<br>
V3(){<br>
System.out.println(&quot;V3&quot;);<br>
}<br>
}<br>
class H1{<br>
public static void main(String[] s){<br>
V3 e1=new V3();<br>
}<br>
}<br>
第五部分  程序设计</p>
<p>11</p>
<ol>
<li>编写一个字符界面的 Java Application 程序，输出 1~9 中除 6 以外所有偶数的平方值（即 2、4、8 的平方值） 。<br>
注：要求使用循环。</li>
<li>编写一个字符界面的 Java Application 程序，使用你熟悉的方法对数组 a[]={20,10,50,40,30,70,60,80,90,100}进行由大<br>
到小的排序。<br>
3.编写一个字符界面的 Java Application 程序，输出所有的水仙花数。<br>
注：水仙花数是一个 3 位数，它的各位数字的立方和等于这个 3 位数自身，如：153=13+53+33则 153 是水仙花数。<br>
4.编写一个字符界面的 Java Application 程序，输出 Fibonacci 序列的前 20 项。<br>
注：Fibonacci 序列定义如下：<br>
第 1 个数为 0<br>
第 2 个数为 1<br>
从第 3 个数开始，每个数是前两个数之和。<br>
如：0  1  1  2  3  5  8  13…<br>
5..设有如下类定义：<br>
public class Array{<br>
static int a[]=new int[5];<br>
int n=5;<br>
}<br>
①添加构造方法，对数组元素初始化。<br>
②设计一个对数组 a 中各元素求和的方法 sum，添加到类 Array 中。<br>
6.创建一个 Fraction 类执行分数运算，要求如下：<br>
①用整型数表示类的 private 成员变量：f1 和 f2。<br>
②提供构造方法，将分子存入 f1，分母存入 f1。<br>
③提供两个分数相加的运算方法，结果的分子存入 f1, 结果的分母存入 f2。<br>
④编写主控程序，实现分数相加运算。<br>
7.设类 Rectangle 定义如下：<br>
public class Rectangle{<br>
static int width,height;<br>
}<br>
在类 Rectangle 中添加两个方法，方法 girth 计算矩形周长，方法计算矩形 area 面积。<br>
8.编写一个日期类 Date，要求：<br>
①日期类 Date 属性有：<br>
year（int 型，代表年） 、month（int 型，代表月） 、day（int 型，代表日）<br>
②日期类 Date 的方法有：<br>
Date()：构造函数，日期默认初值为 2000 年 1 月 1 日。<br>
Date(int y,int m,int d)：构造函数，y、m、d 分别代表年、月、日。<br>
int GetYear()：获取日期的年份作为方法的返回值。<br>
int GetMonth()：获取日期的月份作为方法的返回值。<br>
int GetDayr()：获取日期的日作为方法的返回值。<br>
Void ShowDate()：以“****年<strong>月</strong>日”的形式显示一个日期，如：2001 年 8 月 13 日。<br>
9．编写程序，完成文件复制功能。<br>
10．设计一个 Applet 小程序，使其可以进行简单的加法运算。</li>
<li>编写一个字符界面的 Java Application 程序， 使用你熟悉的方法对数组 a[]={20,10,50,40,30,70,60,80,90,100}进行由大<br>
到小的排序。<br>
12.创建一个 Fraction 类执行分数运算，要求如下：<br>
①用整型数表示类的 private 成员变量：f1 和 f2。<br>
②提供构造方法，将分子存入 f1，分母存入 f1。<br>
③提供两个分数相加的运算方法，结果的分子存入 f1, 结果的分母存入 f2。<br>
④编写主控程序，实现分数相加运算。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[synchronized与volatile]]></title>
        <id>https://song-2020.Github.io/post/synchronized-yu-volatile/</id>
        <link href="https://song-2020.Github.io/post/synchronized-yu-volatile/">
        </link>
        <updated>2020-06-30T15:23:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="synchronized保证三大性原子性有序性可见性">synchronized保证三大性，原子性，有序性，可见性</h1>
<h1 id="volatile保证有序性可见性不能保证原子性">volatile保证有序性，可见性，不能保证原子性</h1>
<h1 id="volatile到底做了什么">volatile到底做了什么:</h1>
<p>禁止了指令重排<br>
保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量值，这个新值对其他线程是立即可见的<br>
不保证原子性（线程不安全）</p>
<h1 id="synchronized关键字和volatile关键字比较">synchronized关键字和volatile关键字比较：</h1>
<p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。<br>
多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞<br>
volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。<br>
volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。<br>
当一个变量定义为 volatile 之后，将具备两种特性：<br>
1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。<br>
2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。<br>
volatile 性能：<br>
volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>
<h1 id="为什么要使用synchronized">为什么要使用synchronized？</h1>
<p>在并发编程中存在线程安全问题，主要原因有：1.存在共享数据 2.多线程共同操作共享数据。<br>
关键字synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile。</p>
<h1 id="相关">相关</h1>
<p>synchronized关键字  : 用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这个段代码。可以对对象加互斥锁。<br>
volatile关键字：用来确保将变量的更新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。然而，在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比 synchronized关键字更轻量级的同步机制。</p>
<h1 id="所谓-volatile的措施就是">所谓 volatile的措施，就是</h1>
<ol>
<li>每次从内存中取值，不从缓存中什么的拿值。这就保证了用 volatile修饰的共享变量，每次的更新对于其他线程都是可见的。</li>
<li>volatile保证了其他线程的立即可见性，就没有保证原子性。<br>
3.由于有些时候对 volatile的操作，不会被保存，说明不会造成阻塞。不可用与多线程环境下的计数器。</li>
</ol>
<p>serialize：Java 对象序列化为二进制文件。<br>
static关键字： static关键字可以修饰变量，方法，静态代码块。<br>
静态变量:<br>
由static修饰的变量称为静态变量<br>
静态变量属于类，而不属于某个对象<br>
静态变量它的副本只有一个(静态变量在类中只加载一)<br>
静态方法：<br>
在静态方法中只能调用静态变量和静态方法<br>
在非静态方法中，可以调用静态方法或者变量。<br>
在静态方法中不能使用this和super关键字。<br>
静态代码块：<br>
作用:用来给静态成员变量初始化</p>
<p>关于原子性，有序性，可见性<br>
可见性：<br>
可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。<br>
可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。<br>
在 Java 中 volatile、synchronized 和 final 实现可见性。<br>
原子性：<br>
原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。<br>
在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。<br>
有序性：<br>
Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Object 类中方法及说明]]></title>
        <id>https://song-2020.Github.io/post/object-lei-zhong-fang-fa-ji-shuo-ming/</id>
        <link href="https://song-2020.Github.io/post/object-lei-zhong-fang-fa-ji-shuo-ming/">
        </link>
        <updated>2020-06-25T15:34:34.000Z</updated>
        <content type="html"><![CDATA[<p>registerNatives()   //私有方法<br>
getClass()    //返回此 Object 的运行类。<br>
hashCode()    //用于获取对象的哈希值。<br>
equals(Object obj)     //用于确认两个对象是否“相同”。<br>
clone()    //创建并返回此对象的一个副本。<br>
toString()   //返回该对象的字符串表示。<br>
notify()    //唤醒在此对象监视器上等待的单个线程。<br>
notifyAll()     //唤醒在此对象监视器上等待的所有线程。<br>
wait(long timeout)    //在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或        者超过指定的时间量前，导致当前线程等待。<br>
wait(long timeout, int nanos)    //在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。<br>
wait()    //用于让当前线程失去操作权限，当前线程进入等待序列<br>
finalize()    //当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[sleep、wait、yield、join]]></title>
        <id>https://song-2020.Github.io/post/sleepwaityieldjoin/</id>
        <link href="https://song-2020.Github.io/post/sleepwaityieldjoin/">
        </link>
        <updated>2020-06-20T15:26:59.000Z</updated>
        <content type="html"><![CDATA[<p>#1.sleep()方法<br>
在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。<br>
sleep()使当前线程进入阻塞状态，在指定时间内不会执行。<br>
#2.wait()方法  会使线程释放锁资源<br>
在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。<br>
当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。<br>
唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。<br>
waite()和notify()必须在synchronized函数或synchronized　block中进行调用。如果在non-synchronized函数或non-synchronized　block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。<br>
#3.yield方法<br>
暂停当前正在执行的线程对象。<br>
yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。<br>
yield()只能使同优先级或更高优先级的线程有执行的机会。<br>
#4.join方法   会使线程释放锁资源<br>
join()等待该线程终止。<br>
等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测</p>
<p>#总结<br>
yield方法：只是简单地对于CPU时间片的“礼让”，除非循环yield，否则一次yield，可能下次该线程仍旧可能会抢占到CPU时间片，可能方法调用和不调用没</p>
<p>#差别<br>
sleep是静态方法，针对当前线程，进入休眠状态，两个版本的sleep方法始终有时间参数，所以必然会在指定的时间内苏醒，他也不会释放锁，当然，sleep方法的调用非必须在同步方法（同步代码块）内</p>
<p>join是实例方法，表示等待谁，是用于线程顺序的调度方法，可以做到一个线程等待另外一个线程，join有三个版本，指定超时时间或者持续等待直到目标线程执行结束，join也无需在同步方法（同步代码块）内</p>
<p>sleep和join都是可中断方法，被其他线程中断时，都会抛出InterruptedException异常，并且会醒来<br>
join方法底层依赖wait，我们对比下wait与sleep<br>
wait和sleep都会使线程进入阻塞状态，都是可中断方法，被中断后都会抛出异常<br>
wait是Object的方法，sleep是Thread的方法<br>
wait必须在同步中执行，sleep不需要（join底层依赖wait，但是不需要在同步中，因为join方法就是synchronized的）<br>
wait会释放锁，sleep不会释放锁<br>
wait（无超时设置的版本）会持续阻塞，必须等待唤醒，而sleep必然有超时，所以一定会自己醒来<br>
wait 实例方法（Object），在对象上调用，表示在其上等待；sleep静态方法，当前线程</p>
<!-- more -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用的三种设计模式：Singleton、Template、Strategy模式]]></title>
        <id>https://song-2020.Github.io/post/chang-yong-de-san-chong-she-ji-mo-shi-singletontemplatestrategy-mo-shi/</id>
        <link href="https://song-2020.Github.io/post/chang-yong-de-san-chong-she-ji-mo-shi-singletontemplatestrategy-mo-shi/">
        </link>
        <updated>2020-06-15T15:30:13.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-singleton单例模式">一、Singleton单例模式</h1>
<p>单例指的只能存在唯一的一个实例对象(单例)<br>
单例模式的设计思路：先阻止类可以类外部通过new的方式(构造函数)创建实例，并在类的内部创建一个获得该类实例的静态方法，用来创建该类实例（不存在实例时）或者返回实例（存在实例时）从而实现单一实例的控制。<br>
Singleton模式首先先对其构造方法的权限声明为private，阻止类外部通过构造方法创建实例，并采用static来共享对象实例，再提供get方法来获取唯一实例。但是要特别注意的是，在懒汉式例程中get方法内部采用了synchronized锁声明（只允许一个线程进入）。<br>
如果没有声明的情况下，如下：</p>
<p>public static LazyMan getlazyman()<br>
{<br>
if(lazyman== null)<br>
{ lazyman = new LazyMan(); }<br>
return lazyman;<br>
}</p>
<pre><code>在多线程下单例模式 使用是非常危险的（不安全的），有可能出现这种情况，唯一实例并未创建时，多个线程都调用类内部创建类的方法，而且都运行到if(lazyman == null)内部而且在运行lazyman = newLazyMan();之前的地方，这就非常尴尬了，这个时候lazyman=null，if里的条件语句是true，所以可以进入到if内部，也就多个线程都通过了我们原本为了限制实例数量的判断语句，而且下一步都是lazyman= new LazyMan();，这样在堆中就存在多个LazyMan实例了，这就和我们预期遐想的不同了。
</code></pre>
<p>Java中四种线程安全的单例模式实现方式：<br>
第一种：饿汉模式（线程安全）<br>
第二种：懒汉模式 （如果方法没有synchronized，则线程不安全）<br>
第三种：懒汉模式改良版（线程安全，使用了double-check，即check-加锁-check，目的是为了减少同步的开销）<br>
第四种：利用私有的内部工厂类（线程安全，内部类也可以换成内部接口，不过工厂类变量的作用于要改为public了。）</p>
<h1 id="二-template模式模板模式">二、Template模式（模板模式）</h1>
<pre><code>    模板模式，顾名思义，设定了模板，并让接下来代码实现都按照一个模板进行，说到模板，很容易就联想到了抽象类和接口的运用，定义了方法名，没有方法体，然后让子类去实现、继承、扩展他们的方法，那么，抽象类和接口的方法不妨就充当了“模板”的作用，也就是骨架，这就是模板模式。
    在模板模式中，可分为抽象模板(AbstractTemplate)和具体模板(Concrete Template)
    抽象模板也就是骨架，定义一个或多个操作(方法)，以便被子类实现。
    具体模板指的就是对抽象模板的实现，也可以说就是子类。在
    抽象模板中的基础方法又可以分为：抽象方法(AbstractMethod)、具体方法(Concrete Method)、钩子方法(Hook Method)
    抽象方法对应抽象类中的抽象方法，具体方法对应抽象类中具体方法，钩子方法对应抽象类（接口）中的空方法。
    例程：//定义了一个抽象类，名字为SteamRice（煮饭、蒸饭），方法分别为PutRice(下米)、WashRice(洗米)、CookRice(煮米)
</code></pre>
<p>//这个类说明了煮饭的基本过程，是煮饭的骨架，什么饭都是这个步骤。<br>
//而它的子类就对其进行了不同的实现，但是骨架还是不变的。</p>
<h1 id="三-strategy策略模式">三、Strategy策略模式</h1>
<pre><code>    在模板设计模式中，我们是通过抽象类（或者实现接口）制作模板，通过继承抽象类（或者实现接口）来实现模板，是一种重心放在子类上的逻辑。而策略模式其逻辑是反过来的，是一种重心放在父类上的逻辑，主要是通过父类对象对子类改写的方法进行调用。    
    在策略模式中，可以通过策略(Strategy)一词来理解这个模式的逻辑，在逻辑上将策略的作用（目的）和策略的具体实施计划分开，父类被称为抽象策略(Strategy)，也就是相当策略的作用（目的），只提供一个骨架，而其子类被称为具体策略(ConcreteStrategy)，也就是相当策略的具体实施计划，每个子类都是一个计划。当然，既然是策略，那么就有策略的使用者，这个使用者在策略模式中称为Context（上下文、环境），正如上面所说的，在Context中创建一个Strategy的对象引用去调用ConcreteStrategy的具体实现。    
    所以，策略模式是相当于对一系列解决方案（或算法等）包装到一系列的策略类里面去，然后通过父类对象去访问具体实现策略的子类，而提供多种解决方案，因为这些方案都是解决相同的问题，所以这些方案都可以互换，都不会影响使用方案的客户端。</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[针对循环优化进行的方法]]></title>
        <id>https://song-2020.Github.io/post/zhen-dui-xun-huan-you-hua-jin-xing-de-fang-fa/</id>
        <link href="https://song-2020.Github.io/post/zhen-dui-xun-huan-you-hua-jin-xing-de-fang-fa/">
        </link>
        <updated>2020-06-01T15:39:33.000Z</updated>
        <content type="html"><![CDATA[<p>#死代码删除，代码外提，强度削弱，删除归纳变量，复写传播</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[String, StringBuffer,StringBuilder的区别]]></title>
        <id>https://song-2020.Github.io/post/string-stringbufferstringbuilder-de-qu-bie/</id>
        <link href="https://song-2020.Github.io/post/string-stringbufferstringbuilder-de-qu-bie/">
        </link>
        <updated>2020-05-28T15:37:39.000Z</updated>
        <content type="html"><![CDATA[<p>java中String、StringBuffer、StringBuilder是编程中经常使用的字符串类，他们之间的区别也是经常在面试中会问到的问题。现在总结一下，看看他们的不同与相同。<br>
#1.可变与不可变<br>
String类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道string对象是不可变的。<br>
private final char value[];<br>
String 为不可变对象,一旦被创建,就不能修改它的值. . 对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去.<br>
StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。<br>
char[] value;<br>
StringBuffer:是一个可变对象,当对他进行修改的时候不会像String那样重新建立对象 , 它只能通过构造函数来建立,  如： StringBuffer sb = new StringBuffer();<br>
不能通过赋值符号对他进行付值. ， 如 sb = &quot;welcome to here!&quot;;//error<br>
对象被建立以后,在内存中就会分配内存空间,并初始保存一个null.向StringBuffer中赋值的时候可以通过它的append方法.      sb.append(&quot;hello&quot;);<br>
#2.是否多线程安全<br>
String中的对象是不可变的，也就可以理解为常量， 显然线程安全 。<br>
AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。<br>
StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是 线程安全的 。看如下源码：</p>
<p>1   public   synchronized  StringBuffer reverse() {<br>
2       super .reverse();<br>
3       return   this ;<br>
4  }<br>
5<br>
6   public   int  indexOf(String str) {<br>
7       return  indexOf(str, 0);         //存在 public synchronized int                 indexOf(String str, int fromIndex) 方法<br>
8  }</p>
<p>StringBuilder并没有对方法进行加同步锁，所以是 非线程安全的 。<br>
#3.StringBuilder与StringBuffer共同点<br>
StringBuilder与StringBuffer有公共父类AbstractStringBuilder( 抽象类 )。<br>
抽象类与接口的其中一个区别是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。<br>
StringBuilder、StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append(...)。只是StringBuffer会在方法上加synchronized关键字，进行同步。<br>
最后，如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。</p>
<p>效率比较String &lt; StringBuffer &lt; StringBuilder，但是在String S1 =“This is only a”+“simple”+“test”时，String效率最高。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java多线程编程]]></title>
        <id>https://song-2020.Github.io/post/java-duo-xian-cheng-bian-cheng/</id>
        <link href="https://song-2020.Github.io/post/java-duo-xian-cheng-bian-cheng/">
        </link>
        <updated>2020-05-15T13:27:03.000Z</updated>
        <content type="html"><![CDATA[<p>#一、定义<br>
Java 给多线程编程提供了内置的支持。<br>
一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。<br>
多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。<br>
这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。<br>
一个线程不能独立的存在，它必须是进程的一部分。<br>
一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。<br>
多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</p>
<p>多进程：<br>
• 当前的操作系统都是多任务OS<br>
• 每个独立执行的任务就是一个进程<br>
• OS将时间划分为多个时间片（时间很短）<br>
• 每个时间片内将CPU分配给某一个任务，时间片结束， CPU将自动回收，再分配给另外任务。从外部看，所有任 务是同时在执行。但是在CPU上，任务是按照串行依次运 行（单核CPU）。如果是多核，多个进程任务可以并行。 但是单个核上，多进程只能串行执行。<br>
• 多进程的优点<br>
–可以同时运行多个任务<br>
–程序因IO堵塞时，可以释放CPU，让CPU为其他程序服务<br>
–当系统有多个CPU时，可以为多个程序同时服务<br>
• 我们的CPU不再提高频率，而是提高核数<br>
• 多核和并行程序才是提高程序性能的唯一办法<br>
• 多进程的缺点<br>
–太笨重，不好管理<br>
–太笨重，不好切换</p>
<p>多线程：<br>
• 一个程序可以包括多个子任务，可串/并行<br>
• 每个子任务可以称为一个线程<br>
• 如果一个子任务阻塞，程序可以将CPU调度另外一个子任 务进行工作。这样CPU还是保留在本程序中，而不是被调 度到别的程序(进程)去。这样，提高本程序所获得CPU时间 和利用率。</p>
<p>多进程和多线程对比<br>
–线程共享数据<br>
–线程通讯更高效<br>
–线程更轻量级，更容易切换<br>
–多个线程更容易管理</p>
<p>#二、一个线程的生命周期<br>
线程是一个动态执行的过程，它也有一个从产生到死亡的过程。<br>
下图显示了一个线程完整的生命周期。<br>
<img src="https://song-2020.Github.io/post-images/1593696513463.png" alt="" loading="lazy"><br>
新建状态:<br>
使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。<br>
就绪状态:<br>
当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。<br>
运行状态:<br>
如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。<br>
阻塞状态:<br>
如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：<br>
等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。<br>
同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。<br>
其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。<br>
死亡状态:<br>
一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>
<p>#三、线程的优先级<br>
每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。<br>
Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。<br>
默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。<br>
具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p>
<p>#四、Java 提供了三种创建线程的方法：<br>
通过实现 Runnable 接口；<br>
通过继承 Thread 类本身；<br>
通过 Callable 和 Future 创建线程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Java中的集合]]></title>
        <id>https://song-2020.Github.io/post/guan-yu-java-zhong-de-ji-he/</id>
        <link href="https://song-2020.Github.io/post/guan-yu-java-zhong-de-ji-he/">
        </link>
        <updated>2020-05-07T12:13:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-概述">一、概述</h1>
<figure data-type="image" tabindex="1"><img src="https://song-2020.Github.io/post-images/1593692066544.png" alt="" loading="lazy"></figure>
<h1 id="二-java集合框架图">二、Java集合框架图</h1>
<p><img src="https://song-2020.Github.io/post-images/1593692291195.png" alt="" loading="lazy"><br>
集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：<br>
接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象<br>
实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。<br>
算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。<br>
除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。</p>
<h1 id="三-集合框架体系">三、集合框架体系</h1>
<figure data-type="image" tabindex="2"><img src="https://song-2020.Github.io/post-images/1593692402821.png" alt="" loading="lazy"></figure>
<h1 id="四-关于线程安全">四、关于线程安全</h1>
<h2 id="1-线程安全thread-safe的集合对象">1、线程安全(Thread-safe)的集合对象：</h2>
<p>Vector 、HashTable 、StringBuffer 、stackenumeration</p>
<h2 id="2-非线程安全的集合对象">2、非线程安全的集合对象：</h2>
<p>ArrayList 、LinkedList、HashMap、HashSet、TreeMap、TreeSet、StringBulider</p>
<h1 id="五-总结">五、总结:</h1>
<h2 id="connection接口">Connection接口:</h2>
<p>—  List 有序,可重复<br>
ArrayList<br>
Arraylist默认数组大小是10，扩容后的大小是扩容前的1.5倍，最大值小于Integer 的最大值减8，如果新创建的集合有带初始值，默认就是传入的大小，也就不会扩容<br>
优点: 底层数据结构是数组，查询快，增删慢。<br>
缺点: 线程不安全，效率高<br>
Vector<br>
优点: 底层数据结构是数组，查询快，增删慢。<br>
缺点: 线程安全，效率低<br>
LinkedList<br>
优点: 底层数据结构是链表，查询慢，增删快。<br>
缺点: 线程不安全，效率高</p>
<p>—Set    无序,不可重复<br>
TreeSet, LinkedHashSet and HashSet 在java中都是实现Set的数据结构<br>
TreeSet, LinkedHashSet and HashSet 的区别：<br>
TreeSet的主要功能用于排序<br>
LinkedHashSet的主要功能用于保证FIFO即有序的集合(先进先出)<br>
HashSet只是通用的存储数据的集合<br>
相同点：Duplicates elements: 因为三者都实现Set interface，所以三者都不包含duplicate elements<br>
Thread safety: 三者都不是线程安全的，如果要使用线程安全可以Collections.synchronizedSet()<br>
不同点：Performance and Speed: HashSet插入数据最快，其次LinkHashSet，最慢的是TreeSet因为内部实现排序<br>
Ordering: HashSet不保证有序，LinkHashSet保证FIFO即按插入顺序排序，TreeSet安装内部实现排序，也可以自定义排序规则<br>
null:HashSet和LinkHashSet允许存在null数据，但是TreeSet中插入null数据时会报NullPointerException</p>
<p>HashSet<br>
底层数据结构是哈希表。(无序,唯一)<br>
如何来保证元素唯一性?<br>
1.依赖两个方法：hashCode()和equals()<br>
LinkedHashSet<br>
底层数据结构是链表和哈希表。(FIFO插入有序,唯一)<br>
1.由链表保证元素有序<br>
2.由哈希表保证元素唯一<br>
TreeSet<br>
底层数据结构是红黑树。(唯一，有序)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java常用基础知识]]></title>
        <id>https://song-2020.Github.io/post/java-chang-yong-ji-chu-zhi-shi/</id>
        <link href="https://song-2020.Github.io/post/java-chang-yong-ji-chu-zhi-shi/">
        </link>
        <updated>2020-04-20T12:06:05.000Z</updated>
        <content type="html"><![CDATA[<p>#java关键字<br>
<img src="https://song-2020.Github.io/post-images/1593691681351.png" alt="" loading="lazy"><br>
#Java三大特性<br>
封装主要是隐藏内部代码；<br>
继承主要是复用现有代码；<br>
多态主要是改写对象行为。<br>
#各种变量的默认值及默认值<br>
<img src="https://song-2020.Github.io/post-images/1593691916709.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>